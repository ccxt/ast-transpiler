{"version":3,"sources":["../node_modules/tsup/assets/esm_shims.js","../src/dirname.cjs","../src/transpiler.ts","../src/pythonTranspiler.ts","../src/baseTranspiler.ts","../src/types.ts","../src/utils.ts","../src/logger.ts","../src/phpTranspiler.ts","../src/csharpTranspiler.ts","../src/goTranspiler.ts"],"sourcesContent":["// Shim globals in esm bundle\nimport { fileURLToPath } from 'url'\nimport path from 'path'\n\nconst getFilename = () => fileURLToPath(import.meta.url)\nconst getDirname = () => path.dirname(getFilename())\n\nexport const __dirname = /* @__PURE__ */ getDirname()\nexport const __filename = /* @__PURE__ */ getFilename()\n","// https://github.com/kulshekhar/ts-jest/issues/1174\nmodule.exports = __dirname;","import ts from 'typescript';\nimport currentPath from \"./dirname.cjs\";\nimport { PythonTranspiler } from './pythonTranspiler.js';\nimport { PhpTranspiler } from './phpTranspiler.js';\nimport { CSharpTranspiler } from './csharpTranspiler.js';\nimport * as path from \"path\";\nimport { Logger } from './logger.js';\nimport { Languages, TranspilationMode, IFileExport, IFileImport, ITranspiledFile, IInput } from './types.js';\nimport { GoTranspiler } from './goTranspiler.js';\n\nconst __dirname_mock = currentPath;\n\nfunction getProgramAndTypeCheckerFromMemory (rootDir: string, text: string, options: any = {}): [any,any,any]  {\n    options = options || ts.getDefaultCompilerOptions();\n    const inMemoryFilePath = path.resolve(path.join(rootDir, \"__dummy-file.ts\"));\n    const textAst = ts.createSourceFile(inMemoryFilePath, text, options.target || ts.ScriptTarget.Latest);\n    const host = ts.createCompilerHost(options, true);\n    function overrideIfInMemoryFile(methodName: keyof ts.CompilerHost, inMemoryValue: any) {\n        const originalMethod = host[methodName] as Function; // eslint-disable-line\n        host[methodName] = (...args: unknown[]) => {\n            // resolve the path because typescript will normalize it\n            // to forward slashes on windows\n            const filePath = path.resolve(args[0] as string);\n            if (filePath === inMemoryFilePath)\n                return inMemoryValue;\n            return originalMethod.apply(host, args);\n        };\n    }\n\n    overrideIfInMemoryFile(\"getSourceFile\", textAst);\n    overrideIfInMemoryFile(\"readFile\", text);\n    overrideIfInMemoryFile(\"fileExists\", true);\n\n    const program = ts.createProgram({\n        options,\n        rootNames: [inMemoryFilePath],\n        host\n    });\n\n    const typeChecker = program.getTypeChecker();\n    const sourceFile = program.getSourceFile(inMemoryFilePath);\n\n    return [ program, typeChecker, sourceFile];\n}\n\nexport default class Transpiler {\n    config;\n    pythonTranspiler: PythonTranspiler;\n    phpTranspiler: PhpTranspiler;\n    csharpTranspiler: CSharpTranspiler;\n    goTranspiler: GoTranspiler;\n    constructor(config = {}) {\n        this.config = config;\n        const phpConfig = config[\"php\"] || {};\n        const pythonConfig = config[\"python\"] || {};\n        const csharpConfig = config[\"csharp\"] || {};\n        const goConfig = config[\"go\"] || {};\n\n        if (\"verbose\" in config) {\n            Logger.setVerboseMode(Boolean(config['verbose']));\n        }\n\n        this.pythonTranspiler = new PythonTranspiler(pythonConfig);\n        this.phpTranspiler = new PhpTranspiler(phpConfig);\n        this.csharpTranspiler = new CSharpTranspiler(csharpConfig);\n        this.goTranspiler = new GoTranspiler(goConfig);\n    }\n\n    setVerboseMode(verbose: boolean) {\n        Logger.setVerboseMode(verbose);\n    }\n\n    createProgramInMemoryAndSetGlobals(content) {\n        const [ memProgram, memType, memSource] = getProgramAndTypeCheckerFromMemory(__dirname_mock, content);\n        global.src = memSource;\n        global.checker = memType as ts.TypeChecker;\n        global.program = memProgram;\n    }\n\n    createProgramByPathAndSetGlobals(path) {\n        const program = ts.createProgram([path], {});\n        const sourceFile = program.getSourceFile(path);\n        const typeChecker = program.getTypeChecker();\n\n        global.src = sourceFile;\n        global.checker = typeChecker;\n        global.program = program;\n    }\n\n    checkFileDiagnostics() {\n        const diagnostics = ts.getPreEmitDiagnostics(global.program, global.src);\n        if (diagnostics.length > 0) {\n            let errorMessage = \"Errors found in the typescript code. Transpilation might produce invalid results:\\n\";\n            diagnostics.forEach( msg => {\n                errorMessage+= \"  - \" + msg.messageText + \"\\n\";\n            });\n            Logger.warning(errorMessage);\n        }\n    }\n\n    transpile(lang: Languages, mode: TranspilationMode, file: string, sync = false, setGlobals = true, handleImports = true): ITranspiledFile {\n        // improve this logic later\n        if (setGlobals) {\n            if (mode === TranspilationMode.ByPath) {\n                this.createProgramByPathAndSetGlobals(file);\n            } else {\n                this.createProgramInMemoryAndSetGlobals(file);\n            }\n\n            // check for warnings and errors\n            this.checkFileDiagnostics();\n        }\n\n        let transpiledContent = undefined;\n        switch(lang) {\n        case Languages.Python:\n            this.pythonTranspiler.asyncTranspiling = !sync;\n            transpiledContent = this.pythonTranspiler.printNode(global.src, -1);\n            this.pythonTranspiler.asyncTranspiling = true; // reset to default\n            break;\n        case Languages.Php:\n            this.phpTranspiler.asyncTranspiling = !sync;\n            transpiledContent = this.phpTranspiler.printNode(global.src, -1);\n            this.phpTranspiler.asyncTranspiling = true; // reset to default\n            break;\n        case Languages.CSharp:\n            transpiledContent = this.csharpTranspiler.printNode(global.src, -1);\n            break;\n        case Languages.Go:\n            transpiledContent = this.goTranspiler.printNode(global.src, -1);\n            break;\n        }\n        let imports = [];\n        let exports = [];\n\n        if (handleImports) {\n            imports = this.pythonTranspiler.getFileImports(global.src);\n            exports = this.pythonTranspiler.getFileExports(global.src);\n        }\n\n        const methodsTypes = this.pythonTranspiler.getMethodTypes(global.src);\n        Logger.success(\"transpilation finished successfully\");\n\n        return {\n            content: transpiledContent,\n            imports,\n            exports,\n            methodsTypes\n        };\n    }\n\n    transpileDifferentLanguagesGeneric(mode: TranspilationMode, input: IInput[], content: string): ITranspiledFile[] {\n        if (mode === TranspilationMode.ByPath) {\n            this.createProgramByPathAndSetGlobals(content);\n        } else {\n            this.createProgramInMemoryAndSetGlobals(content);\n        }\n\n        // check for warnings and errors\n        this.checkFileDiagnostics();\n\n        const files = [];\n        input.forEach( (inp) => {\n            const async = inp.async;\n\n            files.push({\n                content: this.transpile(inp.language, mode, content, !async, false, false).content\n            });\n        });\n\n        const methodsTypes = this.pythonTranspiler.getMethodTypes(global.src);\n\n        const imports = this.pythonTranspiler.getFileImports(global.src);\n        const exports = this.pythonTranspiler.getFileExports(global.src);\n\n        const output =  files.map( (file) => {\n            return {\n                content: file.content,\n                imports,\n                exports,\n                methodsTypes\n            };\n        });\n\n        return output;\n    }\n\n    transpileDifferentLanguages(input: any[], content: string): ITranspiledFile[] {\n        const config = input.map( (inp) => {\n            return {\n                language: this.convertStringToLanguageEnum(inp.language),\n                async: inp.async\n            };\n        } );\n        return this.transpileDifferentLanguagesGeneric(TranspilationMode.ByContent, config, content);\n    }\n\n    transpileDifferentLanguagesByPath(input: any[], content: string): ITranspiledFile[] {\n        const config = input.map( (inp) => {\n            return {\n                language: this.convertStringToLanguageEnum(inp.language),\n                async: inp.async\n            };\n        } );\n        return this.transpileDifferentLanguagesGeneric(TranspilationMode.ByPath, config, content);\n    }\n\n    transpilePython(content): ITranspiledFile {\n        return this.transpile(Languages.Python, TranspilationMode.ByContent, content, !this.pythonTranspiler.asyncTranspiling);\n    }\n\n    transpilePythonByPath(path): ITranspiledFile {\n        return this.transpile(Languages.Python, TranspilationMode.ByPath, path, !this.pythonTranspiler.asyncTranspiling);\n    }\n\n    transpilePhp(content): ITranspiledFile {\n        return this.transpile(Languages.Php, TranspilationMode.ByContent, content, !this.phpTranspiler.asyncTranspiling);\n    }\n\n    transpilePhpByPath(path): ITranspiledFile {\n        return this.transpile(Languages.Php, TranspilationMode.ByPath, path, !this.phpTranspiler.asyncTranspiling);\n    }\n\n    transpileCSharp(content): ITranspiledFile {\n        return this.transpile(Languages.CSharp, TranspilationMode.ByContent, content);\n    }\n\n    transpileCSharpByPath(path): ITranspiledFile {\n        return this.transpile(Languages.CSharp, TranspilationMode.ByPath, path);\n    }\n\n    transpileGoByPath(path): ITranspiledFile {\n        return this.transpile(Languages.Go, TranspilationMode.ByPath, path);\n    }\n\n    transpileGo(content): ITranspiledFile {\n        return this.transpile(Languages.Go, TranspilationMode.ByContent, content);\n    }\n\n\n    getFileImports(content: string): IFileImport[] {\n        this.createProgramInMemoryAndSetGlobals(content);\n        return this.phpTranspiler.getFileImports(global.src);\n    }\n\n    getFileExports(content: string): IFileExport[] {\n        this.createProgramInMemoryAndSetGlobals(content);\n        return this.phpTranspiler.getFileExports(global.src);\n    }\n\n    setPHPPropResolution(props: string[]) {\n        this.phpTranspiler.propRequiresScopeResolutionOperator = props;\n    }\n\n    setPhpUncamelCaseIdentifiers(uncamelCase: boolean) {\n        this.phpTranspiler.uncamelcaseIdentifiers = uncamelCase;\n    }\n\n    setPythonUncamelCaseIdentifiers(uncamelCase: boolean) {\n        this.pythonTranspiler.uncamelcaseIdentifiers = uncamelCase;\n    }\n\n    setPhpAsyncTranspiling(async: boolean) {\n        this.phpTranspiler.asyncTranspiling = async;\n    }\n\n    setPythonAsyncTranspiling(async: boolean) {\n        this.pythonTranspiler.asyncTranspiling = async;\n    }\n\n    setPythonStringLiteralReplacements(replacements): void {\n        this.pythonTranspiler.StringLiteralReplacements = replacements;\n    }\n\n    convertStringToLanguageEnum(lang: string): Languages {\n        switch(lang) {\n        case \"python\":\n            return Languages.Python;\n        case \"php\":\n            return Languages.Php;\n        case \"csharp\":\n            return Languages.CSharp;\n        case \"go\":\n            return Languages.Go;\n        }\n    }\n}\n\nexport {\n    Transpiler\n};\n","import { BaseTranspiler } from \"./baseTranspiler.js\";\nimport { regexAll } from \"./utils.js\";\nimport ts from 'typescript';\n\nconst SyntaxKind = ts.SyntaxKind;\n\nconst parserConfig = {\n    'STATIC_TOKEN': '', // to do static decorator\n    'PUBLIC_KEYWORD': '',\n    'UNDEFINED_TOKEN': 'None',\n    'IF_TOKEN': 'if',\n    'ELSE_TOKEN': 'else',\n    'ELSEIF_TOKEN': 'elif',\n    'THIS_TOKEN': 'self',\n    'AMPERSTAND_APERSAND_TOKEN': 'and',\n    'BAR_BAR_TOKEN': 'or',\n    'SPACE_DEFAULT_PARAM': '',\n    'BLOCK_OPENING_TOKEN': ':',\n    'BLOCK_CLOSING_TOKEN': '',\n    'SPACE_BEFORE_BLOCK_OPENING': '',\n    'CONDITION_OPENING': '',\n    'CONDITION_CLOSE': '',\n    'TRUE_KEYWORD': 'True',\n    'FALSE_KEYWORD': 'False',\n    'THROW_TOKEN': 'raise',\n    'NOT_TOKEN': 'not ',\n    'PLUS_PLUS_TOKEN': ' += 1',\n    'MINUS_MINUS_TOKEN': ' -= 1',\n    'CONSTRUCTOR_TOKEN': 'def __init__',\n    'SUPER_CALL_TOKEN': 'super().__init__',\n    'PROPERTY_ASSIGNMENT_TOKEN': ':',\n    'FUNCTION_TOKEN': 'def',\n    'SUPER_TOKEN': 'super()',\n    'NEW_TOKEN': '',\n    'STRING_QUOTE_TOKEN': '\\'',\n    'LINE_TERMINATOR': '',\n    'METHOD_TOKEN': 'def',\n    'CATCH_TOKEN': 'except',\n    'CATCH_DECLARATION': 'Exception as',\n    'METHOD_DEFAULT_ACCESS': '',\n    'SPREAD_TOKEN': '*',\n    'NULL_TOKEN': 'None',\n};\nexport class PythonTranspiler extends BaseTranspiler {\n    constructor(config = {}) {\n\n        config['parser'] = Object.assign ({}, parserConfig, config['parser'] ?? {});\n\n        super(config);\n        this.id = \"python\";\n\n        this.initConfig();\n        this.asyncTranspiling = config['async'] ?? true;\n        this.uncamelcaseIdentifiers = config['uncamelcaseIdentifiers'] ?? true;\n        this.removeVariableDeclarationForFunctionExpression = config['removeVariableDeclarationForFunctionExpression'] ?? true;\n        this.includeFunctionNameInFunctionExpressionDeclaration = config['includeFunctionNameInFunctionExpressionDeclaration'] ?? true;\n\n        // user overrides\n        this.applyUserOverrides(config);\n    }\n\n    initConfig() {\n        this.LeftPropertyAccessReplacements = {\n            'this': 'self'\n        };\n        this.RightPropertyAccessReplacements = {\n            'push': 'append',\n            'toUpperCase': 'upper',\n            'toLowerCase': 'lower',\n            // 'parseFloat': 'float',\n            // 'parseInt': 'int',\n            'indexOf': 'find',\n            'padEnd': 'ljust',\n            'padStart': 'rjust'\n        };\n        this.FullPropertyAccessReplacements = {\n            'console.log': 'print',\n            'JSON.stringify': 'json.dumps',\n            'JSON.parse': 'json.loads',\n            'Math.log': 'math.log',\n            'Math.abs': 'abs',\n            'Math.min': 'min',\n            'Math.max': 'max',\n            'Math.ceil': 'math.ceil',\n            'Math.round': 'math.round',\n            'Math.floor': 'math.floor',\n            'Math.pow': 'math.pow',\n            'process.exit': 'sys.exit',\n            'Number.MAX_SAFE_INTEGER': 'float(\\'inf\\')',\n        };\n        this.CallExpressionReplacements = {\n            'parseInt': 'int',\n            'parseFloat': 'float',\n        };\n\n        this.PropertyAccessRequiresParenthesisRemoval = [\n            // 'length',\n            // 'toString',\n        ];\n    }\n\n    printArrayIsArrayCall(node, identation, parsedArg = undefined) {\n        return  `isinstance(${parsedArg}, list)`;\n    }\n\n    printObjectKeysCall(node, identation, parsedArg = undefined) {\n        return  `list(${parsedArg}.keys())`;\n    }\n\n    printObjectValuesCall(node, identation, parsedArg = undefined) {\n        return  `list(${parsedArg}.values())`;\n    }\n\n    printPromiseAllCall(node, identation, parsedArg) {\n        return `asyncio.gather(*${parsedArg})`;\n    }\n\n    printMathFloorCall(node, identation, parsedArg = undefined) {\n        return `int(math.floor(${parsedArg}))`;\n    }\n\n    printMathCeilCall(node, identation, parsedArg = undefined) {\n        return `int(math.ceil(${parsedArg}))`;\n    }\n\n    printNumberIsIntegerCall(node, identation , parsedArg = undefined) {\n        return `isinstance(${parsedArg}, int)`;\n    }\n\n    printMathRoundCall(node, identation, parsedArg = undefined) {\n        return `int(round(${parsedArg}))`;\n    }\n\n    printIncludesCall(node, identation, name?, parsedArg?) {\n        return `${parsedArg} in ${name}`;\n    }\n\n    printJoinCall(node: any, identation: any, name?: any, parsedArg?: any) {\n        return `${parsedArg}.join(${name})`;\n    }\n\n    printSplitCall(node: any, identation: any, name?: any, parsedArg?: any) {\n        return `${name}.split(${parsedArg})`;\n    }\n\n    printConcatCall(node: any, identation: any, name?: any, parsedArg?: any) {\n        return `${name} + ${parsedArg}`;\n    }\n\n    printPopCall(node: any, identation: any, name?: any) {\n        return `${name}.pop()`;\n    }\n\n    printShiftCall(node: any, identation: any, name?: any) {\n        return `${name}.pop(0)`;\n    }\n\n    printReverseCall(node, identation, name = undefined) {\n        return `${name}.reverse()`;\n    }\n\n    printArrayPushCall(node, identation, name, parsedArg) {\n        return `${name}.append(${parsedArg})`;\n    }\n\n    printToStringCall(node, identation, name = undefined) {\n        return `str(${name})`;\n    }\n\n    printIndexOfCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `${name}.find(${parsedArg})`;\n    }\n\n    printSearchCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `${name}.find(${parsedArg})`;\n    }\n\n    printStartsWithCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `${name}.startswith(${parsedArg})`;\n    }\n\n    printEndsWithCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `${name}.endswith(${parsedArg})`;\n    }\n\n    printPadEndCall(node, identation, name, parsedArg, parsedArg2) {\n        return `${name}.ljust(${parsedArg}, ${parsedArg2})`;\n    }\n\n    printPadStartCall(node, identation, name, parsedArg, parsedArg2) {\n        return `${name}.rjust(${parsedArg}, ${parsedArg2})`;\n    }\n\n    printTrimCall(node, identation, name = undefined) {\n        return `${name}.strip()`;\n    }\n\n    printToUpperCaseCall(node, identation, name = undefined) {\n        return `${name}.upper()`;\n    }\n\n    printToLowerCaseCall(node, identation, name = undefined) {\n        return `${name}.lower()`;\n    }\n\n    printJsonParseCall(node: any, identation: any, parsedArg?: any) {\n        return `json.loads(${parsedArg})`;\n    }\n\n    printJsonStringifyCall(node: any, identation: any, parsedArg?: any) {\n        return `json.dumps(${parsedArg})`;\n    }\n\n    printReplaceCall(node: any, identation: any, name?: any, parsedArg?: any, parsedArg2?: any) {\n        return `${name}.replace(${parsedArg}, ${parsedArg2})`;\n    }\n\n    printReplaceAllCall(node: any, identation: any, name?: any, parsedArg?: any, parsedArg2?: any) {\n        return `${name}.replace(${parsedArg}, ${parsedArg2})`;\n    }\n\n    printElementAccessExpressionExceptionIfAny(node) {\n        if (node.expression.kind === SyntaxKind.ThisKeyword) {\n            return \"getattr(self, \" + this.printNode(node.argumentExpression, 0) + \")\";\n        }\n    }\n\n    printAssertCall(node, identation, parsedArgs) {\n        return `assert ${parsedArgs}`;\n    }\n\n    printDateNowCall(node, identation) {\n        return \"int(time.time() * 1000)\";\n    }\n\n\n    printForStatement(node, identation) {\n        const varName = node.initializer.declarations[0].name.escapedText;\n        const initValue = this.printNode(node.initializer.declarations[0].initializer, 0);\n        const roofValue = this.printNode(node.condition.right,0);\n\n        const forStm =  this.getIden(identation) + this.FOR_TOKEN +  \" \" + varName + \" in range(\" + initValue + \", \" + roofValue + \"):\\n\" + node.statement.statements.map(st => this.printNode(st, identation+1)).join(\"\\n\");\n        return this.printNodeCommentsIfAny(node, identation, forStm);\n    }\n\n    printPropertyAccessModifiers(node) {\n        return \"\"; // no access modifier in python\n    }\n\n    transformLeadingComment(comment) {\n        const commentRegex = [\n            [ /(^|\\s)\\/\\//g, '$1#' ], // regular comments\n                [ /\\/\\*\\*/, '\\\"\\\"\\\"' ], // eslint-disable-line\n                [ / \\*\\//, '\\\"\\\"\\\"' ], // eslint-disable-line\n                [ /\\[([^\\[\\]]*)\\]\\{@link (.*)\\}/g, '`$1 <$2>`' ], // eslint-disable-line\n            [ /\\s+\\* @method/g, '' ], // docstring @method\n            [ /(\\s+) \\* @description (.*)/g, '$1$2' ], // docstring description\n            [ /\\s+\\* @name .*/g, '' ], // docstring @name\n            [ /(\\s+) \\* @see( .*)/g, '$1see$2' ], // docstring @see\n            [ /(\\s+ \\* @(param|returns) {[^}]*)string([^}]*}.*)/g, '$1str$3' ], // docstring type conversion\n            [ /(\\s+ \\* @(param|returns) {[^}]*)object([^}]*}.*)/g, '$1dict$3' ], // doctstrubg type conversion\n                [ /(\\s+) \\* @returns ([^\\{])/g, '$1:returns: $2' ], // eslint-disable-line\n            [ /(\\s+) \\* @returns \\{(.+)\\}/g, '$1:returns $2:' ], // docstring return\n                [ /(\\s+ \\* @param \\{[\\]\\[\\|a-zA-Z]+\\} )([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+) (.*)/g, '$1$2[\\'$3\\'] $4' ], // eslint-disable-line\n                [ /(\\s+) \\* @([a-z]+) \\{([\\]\\[a-zA-Z\\|]+)\\} ([a-zA-Z0-9_\\-\\.\\[\\]\\']+)/g, '$1:$2 $3 $4:' ],  // eslint-disable-line\n        ];\n\n        const transformed = regexAll(comment, commentRegex);\n        return transformed;\n    }\n\n    transformTrailingComment(comment) {\n        const commentRegex = [\n            [ /(^|\\s)\\/\\//g, '$1#' ], // regular comments\n        ];\n\n        const transformed = regexAll(comment, commentRegex);\n        return \" \" + transformed;\n    }\n\n    transformPropertyAcessExpressionIfNeeded(node: any) {\n        const expression = node.expression;\n        const leftSide = this.printNode(expression, 0);\n        const rightSide = node.name.escapedText;\n\n        let rawExpression = undefined;\n\n        if (rightSide === \"length\") {\n            rawExpression =  \"len(\" + leftSide + \")\";\n        } else if (rightSide === \"toString\") {\n            rawExpression = \"str(\" + leftSide + \")\";\n        }\n        return rawExpression;\n    }\n\n    printClassDefinition(node: any, identation: any): string {\n        const className = node.name.escapedText;\n        const heritageClauses = node.heritageClauses;\n\n        let classInit = \"\";\n        if (heritageClauses !== undefined) {\n            const classExtends = heritageClauses[0].types[0].expression.escapedText;\n            classInit = this.getIden(identation) + \"class \" + className + \"(\" + classExtends + \"):\\n\";\n        } else {\n            classInit = this.getIden(identation) + \"class \" + className + \":\\n\";\n        }\n        return classInit;\n    }\n\n    printMethodParameters(node) {\n        let parsedArgs = super.printMethodParameters(node);\n        parsedArgs = parsedArgs ? \"self, \" + parsedArgs : \"self\";\n        return parsedArgs;\n    }\n\n    printInstanceOfExpression(node, identation) {\n        const left = this.printNode(node.left, 0);\n        const right = this.printNode(node.right, 0);\n        return this.getIden(identation) + `isinstance(${left}, ${right})`;\n    }\n\n    handleTypeOfInsideBinaryExpression(node, identation) {\n        const expression = node.left.expression;\n        const right = node.right.text;\n\n        const op = node.operatorToken.kind;\n        const isDifferentOperator = op === SyntaxKind.ExclamationEqualsEqualsToken || op === SyntaxKind.ExclamationEqualsToken;\n        const notOperator = isDifferentOperator ? this.NOT_TOKEN : \"\";\n\n        switch (right) {\n        case \"string\":\n            return this.getIden(identation) + notOperator + \"isinstance(\" + this.printNode(expression, 0) + \", str)\";\n        case \"number\":\n            return this.getIden(identation) + notOperator + \"isinstance(\" + this.printNode(expression, 0) + \", numbers.Real)\";\n        case \"boolean\":\n            return this.getIden(identation) + notOperator + \"isinstance(\" + this.printNode(expression, 0) + \", bool)\";\n        case \"object\":\n            return this.getIden(identation) + notOperator + \"isinstance(\" + this.printNode(expression, 0) + \", dict)\";\n        case \"undefined\":\n            return this.getIden(identation) + this.printNode(expression, 0) + \" is \" + notOperator + \"None\";\n        }\n\n        return undefined;\n\n    }\n\n    printCustomBinaryExpressionIfAny(node, identation) {\n        const left = node.left;\n        const right = node.right.text;\n\n        const op = node.operatorToken.kind;\n\n        // Fix E712 comparison: if cond == True -> if cond:\n        if ((op === ts.SyntaxKind.EqualsEqualsToken || op === ts.SyntaxKind.EqualsEqualsEqualsToken) && node.right.kind === ts.SyntaxKind.TrueKeyword) {\n            return this.getIden(identation) + this.printNode(node.left, 0);\n        }\n\n        if (left.kind === SyntaxKind.TypeOfExpression) {\n            const typeOfExpression = this.handleTypeOfInsideBinaryExpression(node, identation);\n            if (typeOfExpression) {\n                return typeOfExpression;\n            }\n        }\n\n        const prop = node?.left?.expression?.name?.text;\n\n        if (prop) {\n            const args = left.arguments;\n            const parsedArg =  (args && args.length > 0) ? this.printNode(args[0], 0): undefined;\n            const leftSideOfIndexOf = left.expression.expression;  // myString in myString.indexOf\n            const leftSide = this.printNode(leftSideOfIndexOf, 0);\n            // const rightType = global.checker.getTypeAtLocation(leftSideOfIndexOf); // type of myString in myString.indexOf (\"b\") >= 0;\n\n            switch(prop) {\n            case 'indexOf':\n                if (op === SyntaxKind.GreaterThanEqualsToken && right === '0') {\n                    return this.getIden(identation) + `${parsedArg} in ${leftSide}`;\n                }\n            }\n        }\n        return undefined;\n    }\n\n    printConditionalExpression(node, identation) {\n        const condition = this.printNode(node.condition, 0);\n        const whenTrue = this.printNode(node.whenTrue, 0);\n        const whenFalse = this.printNode(node.whenFalse, 0);\n\n        return this.getIden(identation) + whenTrue + \" if \" + condition + \" else \" + whenFalse;\n    }\n\n    printDeleteExpression(node, identation) {\n        const expression = this.printNode (node.expression);\n        return `del ${expression}`;\n    }\n\n    getCustomOperatorIfAny(left, right, operator) {\n        const rightText = right.getText();\n        const isUndefined = rightText === \"undefined\";\n        if (isUndefined) {\n            switch (operator.kind) {\n            case ts.SyntaxKind.EqualsEqualsToken:\n                return \"is\";\n            case ts.SyntaxKind.ExclamationEqualsToken:\n                return \"is not\";\n            case ts.SyntaxKind.ExclamationEqualsEqualsToken:\n                return \"is not\";\n            case ts.SyntaxKind.EqualsEqualsEqualsToken:\n                return \"is\";\n            }\n        }\n    }\n}\n","import ts from 'typescript';\nimport { IFileImport, IFileExport, TranspilationError, IMethodType, IParameterType } from './types.js';\nimport { unCamelCase } from \"./utils.js\";\nimport { Logger } from \"./logger.js\";\nclass BaseTranspiler {\n\n    NUM_LINES_BETWEEN_CLASS_MEMBERS = 1;\n    LINES_BETWEEN_FILE_MEMBERS = 0;\n    NUM_LINES_END_FILE = 1;\n    SPACE_DEFAULT_PARAM = \" \";\n    BLOCK_OPENING_TOKEN = '{';\n    BLOCK_CLOSING_TOKEN = '}';\n    SPACE_BEFORE_BLOCK_OPENING = ' ';\n    CONDITION_OPENING = '(';\n    CONDITION_CLOSE = ')';\n    DEFAULT_IDENTATION = \"    \";\n    STRING_QUOTE_TOKEN = '\"';\n    UNDEFINED_TOKEN = \"null\";\n    NULL_TOKEN = \"null\";\n    IF_TOKEN = \"if\";\n    ELSE_TOKEN = \"else\";\n    ELSEIF_TOKEN = \"else if\";\n    THIS_TOKEN = \"this\";\n    SLASH_TOKEN = \"/\";\n    ASTERISK_TOKEN = \"*\";\n    PLUS_TOKEN = \"+\";\n    MINUS_TOKEN = \"-\";\n    EQUALS_TOKEN = \"=\";\n    EQUALS_EQUALS_TOKEN = \"==\";\n    EXCLAMATION_EQUALS_TOKEN = \"!=\";\n    EXCLAMATION_EQUALS_EQUALS_TOKEN = \"!=\";\n    EQUALS_EQUALS_EQUALS_TOKEN = \"==\";\n    AMPERSTAND_APERSAND_TOKEN = \"&&\";\n    PLUS_EQUALS = \"+=\";\n    BAR_BAR_TOKEN = \"||\";\n    PERCENT_TOKEN = \"%\";\n    RETURN_TOKEN = \"return\";\n    OBJECT_OPENING = \"{\";\n    OBJECT_CLOSING = \"}\";\n    LEFT_PARENTHESIS = \"(\";\n    RIGHT_PARENTHESIS = \")\";\n    ARRAY_OPENING_TOKEN = \"[\";\n    ARRAY_CLOSING_TOKEN = \"]\";\n    TRUE_KEYWORD = \"true\";\n    FALSE_KEYWORD = \"false\";\n    NEW_CORRESPODENT = \"new\";\n    THROW_TOKEN = \"throw\";\n    AWAIT_TOKEN = \"await\";\n    STATIC_TOKEN = \"static\";\n    CONTINUE_TOKEN = \"continue\";\n    EXTENDS_TOKEN = \":\";\n    NOT_TOKEN = \"!\";\n    SUPER_TOKEN = \"super\";\n    PROPERTY_ACCESS_TOKEN = \".\";\n    TRY_TOKEN = \"try\";\n    CATCH_TOKEN = \"catch\";\n    CATCH_DECLARATION = \"Exception\";\n    BREAK_TOKEN = \"break\";\n    IN_TOKEN = \"in\";\n    LESS_THAN_TOKEN = \"<\";\n    GREATER_THAN_TOKEN = \">\";\n    GREATER_THAN_EQUALS_TOKEN = \">=\";\n    LESS_THAN_EQUALS_TOKEN = \"<=\";\n    PLUS_PLUS_TOKEN = \"++\";\n    MINUS_MINUS_TOKEN = \"--\";\n    CONSTRUCTOR_TOKEN = \"def __init__\";\n    SUPER_CALL_TOKEN = \"super().__init__\";\n    WHILE_TOKEN = \"while\";\n    FOR_TOKEN = \"for\";\n    VAR_TOKEN = \"\";\n\n    METHOD_DEFAULT_ACCESS = \"public\";\n\n    PROPERTY_ASSIGNMENT_TOKEN = \":\";\n    PROPERTY_ASSIGNMENT_OPEN = \"\";\n    PROPERTY_ASSIGNMENT_CLOSE = \"\";\n\n    LINE_TERMINATOR = \";\";\n\n    FUNCTION_TOKEN = \"function\";\n    METHOD_TOKEN = \"function\";\n    ASYNC_TOKEN = \"async\";\n    PROMISE_TYPE_KEYWORD = \"Task\";\n\n    NEW_TOKEN = \"new\";\n\n    STRING_LITERAL_KEYWORD = \"StringLiteral\";\n    STRING_KEYWORD = \"string\";\n    NUMBER_KEYWORD = \"float\";\n\n    PUBLIC_KEYWORD = \"public\";\n    PRIVATE_KEYWORD = \"private\";\n    VOID_KEYWORD = \"void\";\n    BOOLEAN_KEYWORD = \"bool\";\n\n    ARRAY_KEYWORD = \"List<object>\";\n    OBJECT_KEYWORD = \"Dictionary<string, object>\";\n    INTEGER_KEYWORD = \"int\";\n    DEFAULT_RETURN_TYPE = \"object\";\n    DEFAULT_PARAMETER_TYPE = \"object\";\n    DEFAULT_TYPE = \"object\";\n\n    FALSY_WRAPPER_OPEN = \"\";\n    FALSY_WRAPPER_CLOSE = \"\";\n\n    ELEMENT_ACCESS_WRAPPER_OPEN = \"\";\n    ELEMENT_ACCESS_WRAPPER_CLOSE = \"\";\n\n    COMPARISON_WRAPPER_OPEN = \"\";\n    COMPARISON_WRAPPER_CLOSE = \"\";\n\n    UKNOWN_PROP_WRAPPER_OPEN = \"\";\n    UNKOWN_PROP_WRAPPER_CLOSE = \"\";\n\n    UKNOWN_PROP_ASYNC_WRAPPER_OPEN = \"\";\n    UNKOWN_PROP_ASYNC_WRAPPER_CLOSE = \"\";\n\n    EQUALS_EQUALS_WRAPPER_OPEN = \"\";\n    EQUALS_EQUALS_WRAPPER_CLOSE = \"\";\n\n    DIFFERENT_WRAPPER_OPEN = \"\";\n    DIFFERENT_WRAPPER_CLOSE = \"\";\n\n    GREATER_THAN_WRAPPER_OPEN = \"\";\n    GREATER_THAN_WRAPPER_CLOSE = \"\";\n\n    LESS_THAN_WRAPPER_OPEN = \"\";\n    LESS_THAN_WRAPPER_CLOSE = \"\";\n\n    GREATER_THAN_EQUALS_WRAPPER_OPEN = \"\";\n    GREATER_THAN_EQUALS_WRAPPER_CLOSE = \"\";\n\n    LESS_THAN_EQUALS_WRAPPER_OPEN = \"\";\n    LESS_THAN_EQUALS_WRAPPER_CLOSE = \"\";\n\n    DIVIDE_WRAPPER_OPEN = \"\";\n    DIVIDE_WRAPPER_CLOSE = \"\";\n\n    PLUS_WRAPPER_OPEN = \"\";\n    PLUS_WRAPPER_CLOSE = \"\";\n\n    MINUS_WRAPPER_OPEN = \"\";\n    MINUS_WRAPPER_CLOSE = \"\";\n\n    MOD_WRAPPER_OPEN = \"\";\n    MOD_WRAPPER_CLOSE = \"\";\n\n    ARRAY_LENGTH_WRAPPER_OPEN = \"\";\n    ARRAY_LENGTH_WRAPPER_CLOSE = \"\";\n\n    MULTIPLY_WRAPPER_OPEN = \"\";\n    MULTIPLY_WRAPPER_CLOSE = \"\";\n\n    INDEXOF_WRAPPER_OPEN = \"\";\n    INDEXOF_WRAPPER_CLOSE = \"\";\n\n    PARSEINT_WRAPPER_OPEN = \"\";\n    PARSEINT_WRAPPER_CLOSE = \"\";\n\n    DYNAMIC_CALL_OPEN = \"\";\n\n    SPREAD_TOKEN = \"...\";\n\n    INFER_VAR_TYPE = false;\n    INFER_ARG_TYPE = false;\n\n    SupportedKindNames = {};\n    PostFixOperators = {};\n    PrefixFixOperators = {};\n    FunctionDefSupportedKindNames = {};\n\n    LeftPropertyAccessReplacements = {};\n    RightPropertyAccessReplacements = {};\n    FullPropertyAccessReplacements = {};\n    StringLiteralReplacements = {};\n\n    CallExpressionReplacements = {};\n    ReservedKeywordsReplacements = {};\n    PropertyAccessRequiresParenthesisRemoval = [];\n    VariableTypeReplacements = {};\n    ArgTypeReplacements = {};\n\n    FuncModifiers = {};\n    defaultPropertyAccess = 'public';\n\n    uncamelcaseIdentifiers;\n    asyncTranspiling;\n    requiresReturnType;\n    requiresParameterType;\n    supportsFalsyOrTruthyValues;\n    requiresCallExpressionCast;\n    removeVariableDeclarationForFunctionExpression;\n    includeFunctionNameInFunctionExpressionDeclaration;\n    id;\n\n    constructor(config) {\n        Object.assign (this, (config['parser'] || {}));\n        this.id = \"base\";\n        this.uncamelcaseIdentifiers = false;\n        this.requiresReturnType = false;\n        this.requiresParameterType = false;\n        this.supportsFalsyOrTruthyValues = true;\n        this.requiresCallExpressionCast = false;\n        this.removeVariableDeclarationForFunctionExpression = true;\n        this.includeFunctionNameInFunctionExpressionDeclaration = true;\n        this.initOperators();\n    }\n\n    initOperators() {\n        this.SupportedKindNames = {\n            [ts.SyntaxKind.StringLiteral]: this.STRING_LITERAL_KEYWORD,\n            [ts.SyntaxKind.StringKeyword]: this.STRING_KEYWORD,\n            // [ts.SyntaxKind.NumberKeyword]: this.NUMBER_KEYWORD,\n            [ts.SyntaxKind.NumberKeyword]: this.DEFAULT_TYPE,\n            [ts.SyntaxKind.MinusMinusToken]: this.MINUS_MINUS_TOKEN,\n            [ts.SyntaxKind.MinusToken]: this.MINUS_TOKEN,\n            [ts.SyntaxKind.SlashToken]: this.SLASH_TOKEN,\n            [ts.SyntaxKind.AsteriskToken]: this.ASTERISK_TOKEN,\n            [ts.SyntaxKind.InKeyword]: this.IN_TOKEN,\n            [ts.SyntaxKind.PlusToken]: this.PLUS_TOKEN,\n            [ts.SyntaxKind.PercentToken]: this.PERCENT_TOKEN,\n            [ts.SyntaxKind.LessThanToken]: this.LESS_THAN_TOKEN,\n            [ts.SyntaxKind.LessThanEqualsToken]: this.LESS_THAN_EQUALS_TOKEN,\n            [ts.SyntaxKind.GreaterThanToken]: this.GREATER_THAN_TOKEN,\n            [ts.SyntaxKind.GreaterThanEqualsToken]: this.GREATER_THAN_EQUALS_TOKEN,\n            [ts.SyntaxKind.EqualsEqualsToken]: this.EQUALS_EQUALS_TOKEN,\n            [ts.SyntaxKind.EqualsEqualsEqualsToken]: this.EQUALS_EQUALS_EQUALS_TOKEN,\n            [ts.SyntaxKind.EqualsToken]: this.EQUALS_TOKEN,\n            [ts.SyntaxKind.PlusEqualsToken]: this.PLUS_EQUALS,\n            [ts.SyntaxKind.BarBarToken]: this.BAR_BAR_TOKEN,\n            [ts.SyntaxKind.AmpersandAmpersandToken]: this.AMPERSTAND_APERSAND_TOKEN,\n            [ts.SyntaxKind.ExclamationEqualsEqualsToken]: this.EXCLAMATION_EQUALS_EQUALS_TOKEN,\n            [ts.SyntaxKind.ExclamationEqualsToken]: this.EXCLAMATION_EQUALS_TOKEN,\n            [ts.SyntaxKind.AsyncKeyword]: this.ASYNC_TOKEN,\n            [ts.SyntaxKind.AwaitKeyword]: this.AWAIT_TOKEN,\n            [ts.SyntaxKind.StaticKeyword]: this.STATIC_TOKEN,\n            [ts.SyntaxKind.PublicKeyword]: this.PUBLIC_KEYWORD,\n            [ts.SyntaxKind.PrivateKeyword]: this.PRIVATE_KEYWORD,\n            [ts.SyntaxKind.VoidKeyword]: this.VOID_KEYWORD,\n            [ts.SyntaxKind.BooleanKeyword]: this.BOOLEAN_KEYWORD,\n        };\n\n        this.PostFixOperators = {\n            [ts.SyntaxKind.PlusPlusToken]: this.PLUS_PLUS_TOKEN,\n            [ts.SyntaxKind.MinusMinusToken]: this.MINUS_MINUS_TOKEN,\n        };\n\n        this.PrefixFixOperators = {\n            [ts.SyntaxKind.ExclamationToken]: this.NOT_TOKEN,\n            [ts.SyntaxKind.MinusToken]: this.MINUS_TOKEN,\n        };\n\n        this.FunctionDefSupportedKindNames = {\n            [ts.SyntaxKind.StringKeyword]: this.STRING_KEYWORD\n        };\n\n        this.FuncModifiers = {\n            [ts.SyntaxKind.AsyncKeyword]: this.ASYNC_TOKEN,\n            [ts.SyntaxKind.PublicKeyword]: this.PUBLIC_KEYWORD,\n            [ts.SyntaxKind.PrivateKeyword]: this.PRIVATE_KEYWORD,\n            [ts.SyntaxKind.StaticKeyword]: this.STATIC_TOKEN,\n        };\n    }\n\n    capitalize(str: string) {\n        return str[0].toUpperCase() + str.slice(1);\n    }\n\n    applyUserOverrides(config): void {\n        this.LeftPropertyAccessReplacements = Object.assign ({}, this.LeftPropertyAccessReplacements, config['LeftPropertyAccessReplacements'] ?? {});\n        this.RightPropertyAccessReplacements = Object.assign ({}, this.RightPropertyAccessReplacements, config['RightPropertyAccessReplacements'] ?? {});\n        this.FullPropertyAccessReplacements = Object.assign ({}, this.FullPropertyAccessReplacements, config['FullPropertyAccessReplacements'] ?? {});\n        this.CallExpressionReplacements = Object.assign ({}, this.CallExpressionReplacements, config['CallExpressionReplacements'] ?? {});\n        this.StringLiteralReplacements = Object.assign ({}, this.StringLiteralReplacements, config['StringLiteralReplacements'] ?? {});\n    }\n\n    getLineAndCharacterOfNode(node): [number,number] {\n        const { line, character } =\n        global.src.getLineAndCharacterOfPosition(node.getStart());\n        return [line + 1,character];\n    }\n\n    isComment(line: string){\n        line = line.trim();\n        return line.startsWith(\"//\") || line.startsWith(\"/*\") || line.startsWith(\"*\");\n    }\n\n    isStringType(flags: ts.TypeFlags) {\n        return flags === ts.TypeFlags.String || flags === ts.TypeFlags.StringLiteral;\n    }\n\n    isAnyType(flags: ts.TypeFlags) {\n        return flags === ts.TypeFlags.Any;\n    }\n\n    warnIfAnyType(node, flags, variable, target) {\n        if (this.isAnyType(flags)) {\n            const [line, character] = this.getLineAndCharacterOfNode(node);\n            Logger.warning(`[${this.id}] Line: ${line} char: ${character}: ${variable} has any type, ${target} might be incorrectly transpiled`);\n        }\n    }\n\n    warn(node, target, message) {\n        const [line, character] = this.getLineAndCharacterOfNode(node);\n        Logger.warning(`[${this.id}] Line: ${line} char: ${character}: ${target} : ${message}`);\n    }\n\n    isAsyncFunction(node) {\n        let modifiers = node.modifiers;\n        if (modifiers === undefined) {\n            return false;\n        }\n        modifiers = modifiers.filter(mod => mod.kind === ts.SyntaxKind.AsyncKeyword);\n\n        return modifiers.length > 0;\n    }\n\n    getMethodOverride(node: ts.Node): ts.Node {\n        /////\n        //// Warning: Only takes into consideration 1 level of heritage\n        //// might be costly, try to improve its performance later\n        ////\n        // Check if the method is a member of a class\n        if (node === undefined) {\n            return undefined;\n        }\n        if (!ts.isClassDeclaration(node.parent)) {\n            return undefined;\n        }\n\n        // Get the class declaration\n        const classDeclaration = node.parent as ts.ClassDeclaration;\n\n        // Check if the class has a base class\n        if (!classDeclaration.heritageClauses) {\n            return undefined;\n        }\n\n        let method = undefined;\n\n        let parentClass = (ts as any).getAllSuperTypeNodes(node.parent)[0];\n\n        while (parentClass !== undefined) {\n            const parentClassType = global.checker.getTypeAtLocation(parentClass);\n            const parentClassDecl = parentClassType?.symbol?.valueDeclaration;\n\n            if (parentClassDecl === undefined) {\n                this.warn(node, \"Parent class\", \"Parent class not found\");\n                return undefined;\n            }\n\n            const parentClassMembers = parentClassDecl.members ?? [];\n\n            parentClassMembers.forEach(elem=> {\n                if (ts.isMethodDeclaration(elem)) {\n\n                    const name = elem.name.getText().trim();\n                    if ((node as any).name.escapedText === name) {\n                        method = elem;\n                    }\n                }\n            });\n\n            parentClass = (ts as any).getAllSuperTypeNodes(parentClassDecl)[0] ?? undefined;\n        }\n\n\n\n        // TODO: Check if the method has the same signature as a method in the base class\n        return method;\n    }\n\n    getIden (num) {\n        return this.DEFAULT_IDENTATION.repeat(parseInt(num));\n    }\n\n    getBlockOpen(identation){\n        return this.SPACE_BEFORE_BLOCK_OPENING + this.BLOCK_OPENING_TOKEN + \"\\n\";\n    }\n\n    getBlockClose(identation, chainBlock = false) {\n\n        if (chainBlock) {\n            return this.BLOCK_CLOSING_TOKEN ? \"\\n\" + this.getIden(identation) + this.BLOCK_CLOSING_TOKEN  + this.SPACE_BEFORE_BLOCK_OPENING : \"\\n\" + this.getIden(identation) + this.BLOCK_CLOSING_TOKEN;\n        }\n\n        return this.BLOCK_CLOSING_TOKEN ? \"\\n\" + this.getIden(identation) + this.BLOCK_CLOSING_TOKEN : \"\";\n    }\n\n    startsWithUpperCase(str) {\n        return str.charAt(0) === str.charAt(0).toUpperCase();\n    }\n\n    unCamelCaseIfNeeded(name: string): string {\n\n        if (this.uncamelcaseIdentifiers && !this.startsWithUpperCase(name) ) { // avoid snake_case constant (MY_CONSTANT) or exception errors (BadRequestException)\n            return unCamelCase(name) ?? name;\n        }\n        return name;\n    }\n\n    transformIdentifier(node, identifier) {\n        return this.unCamelCaseIfNeeded(identifier);\n    }\n\n    transformCallExpressionName(name: string) {\n        return name;\n    }\n\n    transformPropertyAccessExpressionName(name: string) {\n        return name;\n    }\n\n    printIdentifier(node) {\n        let idValue = node.text ?? node.escapedText;\n\n        if (this.ReservedKeywordsReplacements[idValue]) {\n            idValue = this.ReservedKeywordsReplacements[idValue];\n        }\n\n        if (idValue === \"undefined\") {\n            return this.UNDEFINED_TOKEN;\n        }\n        return this.transformIdentifier(node, idValue); // check this later\n    }\n\n    shouldRemoveParenthesisFromCallExpression(node) {\n        if (node.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            return this.PropertyAccessRequiresParenthesisRemoval.includes(node.expression.name.text);\n        }\n        return false;\n    }\n\n    printInstanceOfExpression(node, identation) {\n        // const left = this.printNode(node.left, 0);\n        // const right = this.printNode(node.right, 0);\n        const left = node.left.escapedText;\n        const right = node.right.escapedText;\n        return this.getIden(identation) + `${left} instanceof ${right}`;\n    }\n\n    getCustomOperatorIfAny(left, right, operator) {\n        return undefined;\n    }\n\n    printCustomBinaryExpressionIfAny(node, identation) {\n        return undefined; // stub to override\n    }\n\n    printBinaryExpression(node, identation) {\n\n        const {left, right, operatorToken} = node;\n\n        const customBinaryExp = this.printCustomBinaryExpressionIfAny(node, identation);\n        if (customBinaryExp) {\n            return customBinaryExp;\n        }\n\n        if (operatorToken.kind == ts.SyntaxKind.InstanceOfKeyword) {\n            return this.printInstanceOfExpression(node, identation);\n        }\n\n        let operator = this.SupportedKindNames[operatorToken.kind];\n\n\n        let leftVar = undefined;\n        let rightVar = undefined;\n\n        // c# wrapper\n        if (operatorToken.kind === ts.SyntaxKind.EqualsEqualsToken || operatorToken.kind === ts.SyntaxKind.EqualsEqualsEqualsToken) {\n            if (this.COMPARISON_WRAPPER_OPEN) {\n                leftVar = this.printNode(left, 0);\n                rightVar = this.printNode(right, identation);\n                return `${this.COMPARISON_WRAPPER_OPEN}${leftVar}, ${rightVar}${this.COMPARISON_WRAPPER_CLOSE}`;\n            }\n        }\n\n        // check if boolean operators || and && because of the falsy values\n        if (operatorToken.kind === ts.SyntaxKind.BarBarToken || operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken) {\n            leftVar = this.printCondition(left, 0);\n            rightVar = this.printCondition(right, identation);\n        }  else {\n            leftVar = this.printNode(left, 0);\n            rightVar = this.printNode(right, identation);\n        }\n\n        const customOperator = this.getCustomOperatorIfAny(left, right, operatorToken);\n\n        operator = customOperator ? customOperator : operator;\n\n        return leftVar +\" \"+ operator + \" \" + rightVar.trim();\n    }\n\n    transformPropertyAcessExpressionIfNeeded (node) {\n        return undefined;\n    }\n\n    transformPropertyAcessRightIdentifierIfNeeded (name: string): string {\n        return this.unCamelCaseIfNeeded(name);\n    }\n\n    getExceptionalAccessTokenIfAny(node) {\n        return undefined; // stub to override\n    }\n\n    printLengthProperty(node, identation, name = undefined) {\n        return undefined; // stub to override\n    }\n\n    printPropertyAccessExpression(node, identation) {\n\n        const expression = node.expression;\n\n        const transformedProperty = this.transformPropertyAcessExpressionIfNeeded(node);\n        if (transformedProperty) {\n            return this.getIden(identation) + transformedProperty;\n        }\n\n        let leftSide = node.expression.escapedText;\n        let rightSide = node.name.escapedText;\n\n        switch (rightSide) {\n        case \"length\":\n            return this.printLengthProperty(node, identation, leftSide);\n        }\n\n        let rawExpression = node.getText().trim();\n\n        if (this.FullPropertyAccessReplacements.hasOwnProperty(rawExpression)){ // eslint-disable-line\n            return this.FullPropertyAccessReplacements[rawExpression]; // eslint-disable-line\n        }\n\n        leftSide = this.LeftPropertyAccessReplacements.hasOwnProperty(leftSide) ? this.LeftPropertyAccessReplacements[leftSide] : this.printNode(expression, 0); // eslint-disable-line\n\n        // checking \"toString\" insde the object will return the builtin toString method :X\n        rightSide = this.RightPropertyAccessReplacements.hasOwnProperty(rightSide) ? // eslint-disable-line\n            this.RightPropertyAccessReplacements[rightSide] :\n            this.transformPropertyAcessRightIdentifierIfNeeded(rightSide) ?? rightSide;\n\n        // join together the left and right side again\n        const accessToken = this.getExceptionalAccessTokenIfAny(node) ?? this.PROPERTY_ACCESS_TOKEN;\n\n        rawExpression = leftSide + accessToken + this.transformPropertyAccessExpressionName(rightSide);\n\n        return rawExpression;\n    }\n\n    printCustomDefaultValueIfNeeded(node) {\n        return undefined;\n    }\n\n    printParameteCustomName(node, name, defaultValue = true) {\n        // useful for when we have to get the parent's method argument type\n        const initializer = node.initializer;\n\n        let type = this.printParameterType(node);\n        type = type ? type + \" \" : \"\";\n\n        if (defaultValue) {\n            if (initializer) {\n                const customDefaultValue = this.printCustomDefaultValueIfNeeded(initializer);\n                const defaultValue = customDefaultValue ? customDefaultValue : this.printNode(initializer, 0);\n                return type + name + this.SPACE_DEFAULT_PARAM + \"=\" + this.SPACE_DEFAULT_PARAM + defaultValue;\n            }\n            return type + name;\n        }\n        return name;\n    }\n\n    printParameter(node, defaultValue = true) {\n        const name = this.printNode(node.name, 0);\n        const initializer = node.initializer;\n\n        let type = this.printParameterType(node);\n        type = type ? type + \" \" : \"\";\n\n        if (defaultValue) {\n            if (initializer) {\n                const customDefaultValue = this.printCustomDefaultValueIfNeeded(initializer);\n                const defaultValue = customDefaultValue ? customDefaultValue : this.printNode(initializer, 0);\n                if (type) {\n                    type = (defaultValue === \"null\" && type !== \"object\") ? type + \"? \": type + \" \";\n                }\n                return type + name + this.SPACE_DEFAULT_PARAM + \"=\" + this.SPACE_DEFAULT_PARAM + defaultValue;\n            }\n            if (type === \"\") {\n                return name;\n            }\n            return type + \" \" + name;\n        }\n        return name;\n    }\n\n    printModifiers(node) {\n        let modifiers = node.modifiers;\n        if (modifiers === undefined) {\n            return \"\";\n        }\n        modifiers = modifiers.filter(mod => this.FuncModifiers[mod.kind]);\n\n        if (!this.asyncTranspiling) {\n            modifiers = modifiers.filter(mod => mod.kind !== ts.SyntaxKind.AsyncKeyword);\n        }\n        const res = modifiers.map(modifier => this.FuncModifiers[modifier.kind]).join(\" \");\n\n        return res;\n    }\n\n    transformLeadingComment(comment) {\n        return comment; // to override\n    }\n\n    transformTrailingComment(comment) {\n        return comment; // to override\n    }\n\n    printLeadingComments(node, identation) {\n        const fullText = global.src.getFullText();\n        const commentsRangeList = ts.getLeadingCommentRanges(fullText, node.pos);\n        const commentsRange = commentsRangeList ? commentsRangeList : undefined;\n        let res = \"\";\n        if (commentsRange) {\n            for (const commentRange of commentsRange) {\n                const commentText = fullText.slice(commentRange.pos, commentRange.end);\n                if (commentText !== undefined) {\n                    const formatted = commentText\n                        .split(\"\\n\")\n                        .map(line=>line.trim())\n                        .map(line => !(line.trim().startsWith(\"*\")) ? this.getIden(identation) + line : this.getIden(identation) + \" \" + line) .join(\"\\n\");\n                    res+= this.transformLeadingComment(formatted) + \"\\n\";\n                }\n            }\n        }\n        return res;\n    }\n\n    printTraillingComment(node, identation) {\n        const fullText = global.src.getFullText();\n        const commentsRangeList = ts.getTrailingCommentRanges(fullText, node.end);\n        const commentsRange = commentsRangeList ? commentsRangeList : undefined;\n        let res = \"\";\n        if (commentsRange) {\n            for (const commentRange of commentsRange) {\n                const commentText = fullText.slice(commentRange.pos, commentRange.end);\n                if (commentText !== undefined) {\n                    res+= \" \" + this.transformTrailingComment(commentText);\n                }\n            }\n        }\n        return res;\n    }\n\n    printNodeCommentsIfAny(node, identation, parsedNode) {\n        const leadingComment = this.printLeadingComments(node, identation);\n        const trailingComment = this.printTraillingComment(node, identation);\n        return leadingComment + parsedNode + trailingComment;\n    }\n\n    getType(node) {\n        // try to get type from declared type, example: x: string = \"foo\"\n        const type = node.type;\n        if (type) {\n            if (type.kind === ts.SyntaxKind.TypeReference) {\n                const typeRef = type.typeName.escapedText;\n                if (typeRef === \"Promise\") {\n                    const typeArgs = type.typeArguments.filter(t => t.kind !== ts.SyntaxKind.VoidKeyword);\n                    const insideTypes = typeArgs.map(type => {\n                        if (this.SupportedKindNames.hasOwnProperty(type.kind)) {  // eslint-disable-line\n                            return this.SupportedKindNames[type.kind];\n                        } else {\n                            return type.escapedText;\n                        }\n                    }).join(\",\");\n\n                    if (insideTypes.length > 0) {\n                        return `${this.PROMISE_TYPE_KEYWORD}<${insideTypes}>`;\n                    }\n                    return this.PROMISE_TYPE_KEYWORD;\n                }\n                return type.typeName.escapedText;\n            } else if (this.SupportedKindNames.hasOwnProperty(type.kind)) { // eslint-disable-line\n                return this.SupportedKindNames[type.kind];\n            }\n        }\n\n        // todo: infer from initializer re-think this logic ex: x = 1;\n        // can we use the type checker here?\n        const initializer = node.initializer;\n        if (initializer) {\n            if (ts.isArrayLiteralExpression(initializer)) {\n                return this.ARRAY_KEYWORD;\n            }\n            if ((ts as any).isBooleanLiteral(initializer)) {\n                return this.BOOLEAN_KEYWORD;\n            }\n            if (ts.isObjectLiteralExpression(initializer)) {\n                return this.OBJECT_KEYWORD;\n            }\n            if (ts.isNumericLiteral(initializer)) {\n                // return this.NUMBER_TYPE_TOKEN;\n                // const value = initializer.text;\n                // const num = Number(value);\n                // if (Number.isInteger(num)) {\n                //     return this.INTEGER_KEYWORD;\n                // }\n                // return this.NUMBER_KEYWORD;\n                return this.DEFAULT_TYPE; // int and number to object\n            }\n            if (ts.isStringLiteralLike(initializer)) {\n                return this.STRING_KEYWORD;\n            }\n        }\n        return undefined;\n    }\n\n    getTypeFromRawType(type) {\n        // check for primitive types\n        if (type.flags === ts.TypeFlags.Any) {\n            return undefined;\n        }\n        if (type.flags === ts.TypeFlags.Void) {\n            return this.VOID_KEYWORD;\n        }\n        if (type.flags === ts.TypeFlags.Number) {\n            // return this.NUMBER_KEYWORD;\n            return this.DEFAULT_TYPE;\n        }\n\n        if (type.flags === ts.TypeFlags.String) {\n            return this.STRING_KEYWORD;\n        }\n        // if (type.flags === ts.TypeFlags.Boolean) {\n        //     return this.BOOLEAN_KEYWORD;\n        // }\n\n        // check for array or object\n\n        if (type?.symbol?.escapedName === 'Array') {\n            return this.ARRAY_KEYWORD;\n        }\n        if (type?.symbol?.escapedName === '__object') {\n            return this.OBJECT_KEYWORD;\n        }\n\n        // check this out, trying to resolve Promise<{}>\n        if (type?.symbol?.escapedName === '__type') {\n            return this.OBJECT_KEYWORD;\n            // return this.DEFAULT_TYPE;\n        }\n\n        // check for promise type\n\n        if (type?.symbol?.escapedName === 'Promise') {\n            return this.PROMISE_TYPE_KEYWORD;\n        }\n\n        // check this out not sure about this\n        if (type?.intrinsicName === 'object') {\n            return this.OBJECT_KEYWORD;\n        }\n        if (type?.intrinsicName === 'boolean') {\n            return this.BOOLEAN_KEYWORD;\n        }\n\n        return undefined;\n    }\n\n    getFunctionType(node, async = true){\n        // use type checker to do it here\n        const type = global.checker.getReturnTypeOfSignature(global.checker.getSignatureFromDeclaration(node));\n\n        const parsedTtype = this.getTypeFromRawType(type);\n\n        if (parsedTtype === this.PROMISE_TYPE_KEYWORD) {\n            if (type.resolvedTypeArguments.length === 0) {\n                return this.PROMISE_TYPE_KEYWORD;\n            }\n            if (type.resolvedTypeArguments.length === 1 && type.resolvedTypeArguments[0].flags === ts.TypeFlags.Void) {\n                return this.PROMISE_TYPE_KEYWORD;\n            }\n\n            const insideTypes = type.resolvedTypeArguments.map(type => this.getTypeFromRawType(type)).join(\",\");\n            if (insideTypes.length > 0) {\n                if (async) {\n                    return `${this.PROMISE_TYPE_KEYWORD}<${insideTypes}>`;\n                } else {\n                    return insideTypes;\n                }\n            }\n            return undefined;\n        }\n        return parsedTtype;\n    }\n\n    printFunctionBody(node, identation) {\n        return this.printBlock(node.body, identation);\n    }\n\n    printParameterType(node) {\n        if (!this.requiresParameterType) {\n            return \"\";\n        }\n\n        if (!this.INFER_ARG_TYPE) {\n            return this.DEFAULT_PARAMETER_TYPE;\n        }\n\n        const type = global.checker.typeToString(global.checker.getTypeAtLocation(node));\n\n        if (this.ArgTypeReplacements[type]) {\n            return this.ArgTypeReplacements[type];\n        }\n\n        return this.DEFAULT_PARAMETER_TYPE;\n    }\n\n    printFunctionType(node){\n        if (!this.requiresReturnType) {\n            return \"\";\n        }\n\n        const typeText = this.getFunctionType(node);\n        if (typeText === undefined || (typeText !== this.VOID_KEYWORD && typeText !== this.PROMISE_TYPE_KEYWORD)) {\n            // throw new FunctionReturnTypeError(\"Function return type is not supported\");\n            let res = \"\";\n            if (this.isAsyncFunction(node)) {\n                res = `${this.PROMISE_TYPE_KEYWORD}<${this.DEFAULT_RETURN_TYPE}>`;\n            } else {\n                res = this.DEFAULT_RETURN_TYPE;\n            }\n            this.warn(node, node.name.getText(), \"Function return type not found, will default to: \" + res);\n            return res;\n        }\n        return typeText;\n    }\n\n    printFunctionDefinition(node, identation) {\n        let name = node.name?.escapedText ?? \"\";\n        name = this.transformFunctionNameIfNeeded(name);\n\n        const parsedArgs = node.parameters.map(param => this.printParameter(param)).join(\", \");\n\n        let modifiers = this.printModifiers(node);\n        modifiers = modifiers ? modifiers + \" \" : modifiers;\n\n        let returnType = this.printFunctionType(node);\n        returnType = returnType ? returnType + \" \" : returnType;\n\n        const fnKeyword = this.FUNCTION_TOKEN ? this.FUNCTION_TOKEN + \" \" : \"\";\n        if (!fnKeyword && ts.isFunctionDeclaration(node)){\n            modifiers = modifiers + \"public \";\n        }\n        let functionDef = this.getIden(identation) + modifiers + returnType + fnKeyword;\n        if (this.includeFunctionNameInFunctionExpressionDeclaration ||  !ts.isFunctionExpression(node)) {\n            functionDef += name;\n        }\n        functionDef += \"(\" + parsedArgs + \")\";\n\n        return functionDef;\n    }\n\n    transformFunctionNameIfNeeded(name): string {\n        return this.unCamelCaseIfNeeded(name);\n    }\n\n    printFunctionDeclaration(node, identation) {\n        if (ts.isArrowFunction(node)) {\n            const parameters = node.parameters.map(param => this.printParameter(param)).join(\", \");\n            const body = this.printNode(node.body);\n            return `(${parameters}) => ${body}`;\n        }\n        let functionDef = this.printFunctionDefinition(node, identation);\n        const funcBody = this.printFunctionBody(node, identation);\n        functionDef += funcBody;\n\n        return this.printNodeCommentsIfAny(node, identation, functionDef);\n    }\n\n    printMethodParameters(node) {\n        return node.parameters.map(param => this.printParameter(param)).join(\", \");\n    }\n\n    transformMethodNameIfNeeded(name: string): string {\n        return this.unCamelCaseIfNeeded(name);\n    }\n\n    printMethodDefinition(node, identation) {\n        let name = node.name.escapedText;\n        name = this.transformMethodNameIfNeeded(name);\n\n        let returnType = this.printFunctionType(node);\n\n        let modifiers = this.printModifiers(node);\n        const defaultAccess = this.METHOD_DEFAULT_ACCESS ? this.METHOD_DEFAULT_ACCESS + \" \": \"\";\n        modifiers = modifiers ? modifiers + \" \" : defaultAccess; // tmp check this\n\n        const parsedArgs = this.printMethodParameters(node);\n\n        returnType = returnType ? returnType + \" \" : returnType;\n\n        const methodToken = this.METHOD_TOKEN ? this.METHOD_TOKEN + \" \" : \"\";\n        const methodDef = this.getIden(identation) + modifiers + returnType + methodToken + name\n            + \"(\" + parsedArgs + \")\";\n\n        return this.printNodeCommentsIfAny(node, identation, methodDef);\n    }\n\n    printMethodDeclaration(node, identation) {\n\n        let methodDef = this.printMethodDefinition(node, identation);\n\n        const funcBody = this.printFunctionBody(node, identation);\n\n        methodDef += funcBody;\n\n        return methodDef;\n    }\n\n    printStringLiteral(node) {\n        const token = this.STRING_QUOTE_TOKEN;\n        let text = node.text;\n        if (text in this.StringLiteralReplacements) {\n            return this.StringLiteralReplacements[text];\n        }\n        text = text.replaceAll(\"\\b\", \"\\\\b\");\n        text = text.replaceAll(\"\\f\", \"\\\\f\");\n        text = text.replaceAll(\"\\n\", \"\\\\n\");\n        text = text.replaceAll(\"\\r\", \"\\\\r\");\n        text = text.replaceAll(\"\\t\", \"\\\\t\");\n        if (token === \"'\") {\n            text = text.replaceAll(\"\\\\\\\"\", \"\\\"\"); // unscape double quotes\n            text = text.replaceAll(\"'\", \"\\\\'\"); // escape single quotes\n        } else if (token === \"\\\"\") {\n            text = text.replaceAll(\"\\\"\", \"\\\\\\\"\"); // escape double quotes\n        }\n        return token + text + token;\n    }\n\n    printNumericLiteral(node) {\n        return node.text;\n    }\n\n    printArrayLiteralExpression(node, identation) {\n\n        const elements = node.elements.map((e) => {\n            return this.printNode(e);\n        }).join(\", \");\n        return this.ARRAY_OPENING_TOKEN + elements  + this.ARRAY_CLOSING_TOKEN;\n    }\n\n    printVariableDeclarationList(node,identation) {\n        const declaration = node.declarations[0];\n        const varToken = this.VAR_TOKEN ? this.VAR_TOKEN + \" \": \"\";\n\n        if (this.removeVariableDeclarationForFunctionExpression && declaration?.initializer && (ts.isFunctionExpression(declaration.initializer) || ts.isArrowFunction(declaration.initializer))) {\n            return this.printNode(declaration.initializer, identation).trimEnd();\n        }\n        // const name = declaration.name.escapedText;\n        const parsedValue = (declaration.initializer) ? this.printNode(declaration.initializer, identation) : this.NULL_TOKEN;\n        return this.getIden(identation) + varToken + this.printNode(declaration.name) + \" = \" + parsedValue.trim();\n    }\n\n    printVariableStatement(node, identation){\n\n        if (this.isCJSRequireStatement(node)) {\n            return \"\"; // remove cjs imports\n        }\n\n        const decList = node.declarationList;\n        const varStatement = this.printVariableDeclarationList(decList, identation) + this.LINE_TERMINATOR;\n        return this.printNodeCommentsIfAny(node, identation, varStatement);\n    }\n\n    printOutOfOrderCallExpressionIfAny(node, identation) {\n        return undefined; // stub to override\n    }\n\n    printSuperCallInsideConstructor(node, identation) {\n        const args = node.arguments;\n\n        const parsedArgs = args.map((a) => {\n            return this.printNode(a, identation).trim();\n        }).join(\",\");\n        return this.SUPER_CALL_TOKEN + \"(\" + parsedArgs + \")\";\n    }\n\n    isBuiltInFunctionCall(node) {\n        const symbol = global.checker.getSymbolAtLocation(node);\n        const isInLibFiles = symbol?.getDeclarations()\n            ?.some(s => s.getSourceFile().fileName.includes(\"/node_modules/typescript/lib/\"))\n            ?? false;\n\n\n        return isInLibFiles;\n    }\n\n    getTypesFromCallExpressionParameters(node) {\n        const resolvedParams = global.checker.getResolvedSignature(node).parameters;\n        const parsedTypes = [];\n        resolvedParams.forEach((p) => {\n            const decl = p.declarations[0];\n            const type = global.checker.getTypeAtLocation(decl);\n            const parsedType = this.getTypeFromRawType(type);\n            parsedTypes.push(parsedType);\n        });\n        return parsedTypes;\n    }\n\n    printArgsForCallExpression(node, identation) {\n        const args = node.arguments;\n\n        const argsList = args.length > 0 ? args : [];\n        const parsedArgs = argsList.map((a) => {\n            return  this.printNode(a, identation).trim();\n        }).join(\", \");\n        return parsedArgs;\n    }\n\n    // builtin functions override\n    printArrayIsArrayCall(node, identation, parsedArg = undefined) {\n        return undefined; // stub\n    }\n\n    printObjectKeysCall(node, identation, parsedArg = undefined) {\n        return undefined; // stub\n    }\n\n    printObjectValuesCall(node, identation, parsedArg = undefined) {\n        return undefined; // stub\n    }\n\n    printJsonParseCall(node, identation, parsedArg = undefined) {\n        return undefined; // stub\n    }\n\n    printJsonStringifyCall(node, identation, parsedArg = undefined) {\n        return undefined; // stub\n    }\n\n\n    printPromiseAllCall(node, identation, parsedArg = undefined) {\n        return undefined; // stub\n    }\n\n    printMathFloorCall(node, identation, parsedArg = undefined) {\n        return undefined; // stub\n    }\n\n    printMathRoundCall(node, identation, parsedArg = undefined) {\n        return undefined; // stub\n    }\n\n    printMathCeilCall(node, identation, parsedArg = undefined) {\n        return undefined; // stub\n    }\n\n    printNumberIsIntegerCall(node, identation, parsedArg = undefined) {\n        return undefined; // stub\n    }\n\n    printArrayPushCall(node, identation, name = undefined, parsedArg = undefined) {\n        return undefined; // stub\n    }\n\n    printIncludesCall(node, identation, name = undefined, parsedArg = undefined) {\n        return undefined; // stub\n    }\n\n    printIndexOfCall(node, identation, name = undefined, parsedArg = undefined) {\n        return undefined; // stub\n    }\n\n    printStartsWithCall(node, identation, name = undefined, parsedArg = undefined) {\n        return undefined; // stub\n    }\n\n    printEndsWithCall(node, identation, name = undefined, parsedArg = undefined) {\n        return undefined; // stub\n    }\n\n    printPadEndCall(node, identation, name, parsedArg, parsedArg2) {\n        return undefined; // stub\n    }\n\n    printPadStartCall(node, identation, name, parsedArg, parsedArg2) {\n        return undefined; // stub\n    }\n\n    printTrimCall(node, identation, name = undefined) {\n        return undefined; // stub\n    }\n\n    printJoinCall(node, identation, name = undefined, parsedArg = undefined) {\n        return undefined; // stub\n    }\n\n    printSplitCall(node, identation, name = undefined, parsedArg = undefined) {\n        return undefined; // stub\n    }\n\n    printConcatCall(node, identation, name = undefined, parsedArg = undefined) {\n        return undefined; // stub\n    }\n\n    printToFixedCall(node, identation, name = undefined, parsedArg = undefined) {\n        return undefined; // stub\n    }\n\n    printSearchCall(node, identation, name = undefined, parsedArg = undefined) {\n        return undefined; // stub\n    }\n\n    printSliceCall(node, identation, name = undefined, parsedArg = undefined, parsedArg2 = undefined) {\n        return undefined; // stub\n    }\n\n    printReplaceCall(node, identation, name = undefined, parsedArg = undefined, parsedArg2 = undefined) {\n        return undefined; // stub\n    }\n\n    printReplaceAllCall(node, identation, name = undefined, parsedArg = undefined, parsedArg2 = undefined) {\n        return undefined; // stub\n    }\n\n    printToStringCall(node, identation, name = undefined) {\n        return undefined; // stub\n    }\n\n    printToUpperCaseCall(node, identation, name = undefined) {\n        return undefined; // stub\n    }\n\n    printToLowerCaseCall(node, identation, name = undefined) {\n        return undefined; // stub\n    }\n\n    printShiftCall(node, identation, name = undefined) {\n        return undefined; // stub\n    }\n\n    printReverseCall(node, identation, name = undefined) {\n        return undefined; // stub\n    }\n\n    printPopCall(node, identation, name = undefined) {\n        return undefined; // stub\n    }\n\n    printAssertCall(node, identation, parsedArgs) {\n        return `assert(${parsedArgs})`;\n    }\n\n    printDateNowCall(node, identation) {\n        return undefined; // stub\n    }\n\n    printCallExpression(node, identation) {\n        const expression = node.expression;\n\n        const parsedArgs = this.printArgsForCallExpression(node, identation);\n\n        const removeParenthesis = this.shouldRemoveParenthesisFromCallExpression(node);\n\n        const finalExpression = this.printOutOfOrderCallExpressionIfAny(node, identation);\n        if (finalExpression) {\n            return finalExpression;\n        }\n\n        // check propertyAccessExpression for built in functions calls like Json.parse\n        if (node.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const expressionText = node.expression.getText().trim();\n            const args = node.arguments ?? [];\n\n            if (args.length === 0) {\n                switch(expressionText) {\n                case \"Date.now\":\n                    return this.printDateNowCall(node, identation);\n                }\n            }\n\n            if (args.length === 1) {\n                const parsedArg = this.printNode(args[0], 0);\n                switch (expressionText) {\n                case \"JSON.parse\":\n                    return this.printJsonParseCall(node, identation, parsedArg);\n                case \"JSON.stringify\":\n                    return this.printJsonStringifyCall(node, identation, parsedArg);\n                case \"Array.isArray\":\n                    return this.printArrayIsArrayCall(node, identation, parsedArg);\n                case \"Object.keys\":\n                    return this.printObjectKeysCall(node, identation, parsedArg);\n                case \"Object.values\":\n                    return this.printObjectValuesCall(node, identation, parsedArg);\n                case \"Promise.all\":\n                    return this.printPromiseAllCall(node, identation, parsedArg);\n                case \"Math.round\":\n                    return this.printMathRoundCall(node, identation, parsedArg);\n                case \"Math.floor\":\n                    return this.printMathFloorCall(node, identation, parsedArg);\n                case \"Math.ceil\":\n                    return this.printMathCeilCall(node, identation, parsedArg);\n                case \"Number.isInteger\":\n                    return this.printNumberIsIntegerCall(node, identation, parsedArg);\n                }\n            }\n            const rightSide = node.expression.name?.escapedText;\n            const leftSide = node.expression?.expression;\n\n            if (args.length === 0 && rightSide !== undefined && leftSide !== undefined) {\n                const parsedLeftSide = this.printNode(leftSide, 0);\n                switch (rightSide) {\n                case \"toString\":\n                    return this.printToStringCall(node, identation, parsedLeftSide);\n                case \"toUpperCase\":\n                    return this.printToUpperCaseCall(node, identation, parsedLeftSide);\n                case \"toLowerCase\":\n                    return this.printToLowerCaseCall(node, identation, parsedLeftSide);\n                case \"shift\":\n                    return this.printShiftCall(node, identation, parsedLeftSide);\n                case \"pop\":\n                    return this.printPopCall(node, identation, parsedLeftSide);\n                case \"reverse\":\n                    return this.printReverseCall(node, identation, parsedLeftSide);\n                case \"trim\":\n                    return this.printTrimCall(node, identation, parsedLeftSide);\n                }\n            }\n\n            // handle built in functions like\n\n            const arg = args && args.length > 0 ? args[0] : undefined;\n\n            if (leftSide && rightSide && arg) {\n                const parsedArg = this.printNode(arg, identation).trimStart();\n                const secondParsedArg = args[1] ? this.printNode(args[1], identation).trimStart() : undefined;\n                const name = this.printNode(leftSide, 0);\n                switch(rightSide) {\n                case 'push':\n                    return this.printArrayPushCall(node, identation, name, parsedArg);\n                case 'includes':\n                    return this.printIncludesCall(node, identation, name, parsedArg);\n                case 'indexOf':\n                    return this.printIndexOfCall(node, identation, name, parsedArg);\n                case 'join':\n                    return this.printJoinCall(node, identation, name, parsedArg);\n                case 'split':\n                    return this.printSplitCall(node, identation, name, parsedArg);\n                case 'toFixed':\n                    return this.printToFixedCall(node, identation, name, parsedArg);\n                case 'concat':\n                    return this.printConcatCall(node, identation, name, parsedArg);\n                case 'search':\n                    return this.printSearchCall(node, identation, name, parsedArg);\n                case 'endsWith':\n                    return this.printEndsWithCall(node, identation, name, parsedArg);\n                case 'startsWith':\n                    return this.printStartsWithCall(node, identation, name, parsedArg);\n                case 'padEnd':\n                    return this.printPadEndCall(node, identation, name, parsedArg, secondParsedArg);\n                case 'padStart':\n                    return this.printPadStartCall(node, identation, name, parsedArg, secondParsedArg);\n                }\n\n                if (args.length === 1 || args.length === 2) {\n                    const parsedArg2 = args[1] ? this.printNode(args[1], identation).trimStart() : undefined;\n                    switch(rightSide) {\n                    case 'slice':\n                        return this.printSliceCall(node, identation, name, parsedArg, parsedArg2);\n                    case 'replace':\n                        return this.printReplaceCall(node, identation, name, parsedArg, parsedArg2);\n                    case 'replaceAll':\n                        return this.printReplaceAllCall(node, identation, name, parsedArg, parsedArg2);\n                    }\n                }\n            }\n        }  else {\n            // handle functions like assert\n            const args = node.arguments ?? [];\n            if (args.length === 2) {\n                if ( expression.escapedText === \"assert\") {\n                    return this.printAssertCall(node, identation, parsedArgs);\n                }\n                if (expression.escapedText === \"padEnd\") {\n                    // check this\n                }\n            }\n        }\n\n        // print super() call inside constructor\n        if (expression.kind === ts.SyntaxKind.SuperKeyword) {\n            return this.printSuperCallInsideConstructor(node, identation);\n        }\n\n        let parsedExpression = undefined;\n        if (this.CallExpressionReplacements.hasOwnProperty(expression.getText())) { // eslint-disable-line\n            parsedExpression = this.CallExpressionReplacements[expression.getText()];\n        } else {\n            if (expression.kind === ts.SyntaxKind.Identifier) {\n                const idValue = expression.text ?? expression.escapedText;\n                parsedExpression = this.transformCallExpressionName(this.unCamelCaseIfNeeded(idValue));\n            } else {\n                parsedExpression = this.printNode(expression, 0);\n            }\n        }\n\n        let parsedCall = parsedExpression;\n        if (!removeParenthesis) {\n            parsedCall+= \"(\" + parsedArgs + \")\";\n\n        }\n        return parsedCall;\n    }\n\n    printClassBody(node, identation) {\n        // const parsedMembers = node.members.map(m => this.printNode(m, identation+1));\n\n        const parsedMembers = [];\n        node.members.forEach( (m, index) => {\n            const parsedNode = this.printNode(m, identation+1);\n            if (m.kind  === ts.SyntaxKind.PropertyDeclaration || index === 0) {\n                parsedMembers.push(parsedNode);\n            } else {\n                parsedMembers.push(\"\\n\".repeat(this.NUM_LINES_BETWEEN_CLASS_MEMBERS) + parsedNode);\n            }\n        });\n        return parsedMembers.join(\"\\n\");\n    }\n\n    printClassDefinition(node, identation) {\n        const className = node.name.escapedText;\n        const heritageClauses = node.heritageClauses;\n\n        let classInit = \"\";\n        const classOpening = this.getBlockOpen(identation);\n        if (heritageClauses !== undefined) {\n            const classExtends = heritageClauses[0].types[0].expression.escapedText;\n            classInit = this.getIden(identation) + \"class \" + className + \" \" + this.EXTENDS_TOKEN + \" \" + classExtends + classOpening;\n        } else {\n            classInit = this.getIden(identation) + \"class \" + className + classOpening;\n        }\n        return classInit;\n    }\n\n    printClass(node, identation) {\n\n        const classDefinition = this.printClassDefinition(node, identation);\n\n        const classBody = this.printClassBody(node, identation);\n\n        const classClosing = this.getBlockClose(identation);\n\n        return classDefinition + classBody + classClosing;\n    }\n\n    printConstructorDeclaration (node, identation) {\n        const args = this.printMethodParameters(node);\n        const constructorBody = this.printFunctionBody(node, identation);\n        return this.getIden(identation) +\n                this.CONSTRUCTOR_TOKEN +\n                \"(\" + args + \")\" +\n                constructorBody;\n    }\n\n    printWhileStatement(node, identation) {\n        const loopExpression = node.expression;\n\n        const expression = this.printNode(loopExpression, 0);\n\n        const whileStm = this.getIden(identation) +\n                    this.WHILE_TOKEN + \" \" +\n                    this.CONDITION_OPENING + expression + this.CONDITION_CLOSE +\n                    this.printBlock(node.statement, identation);\n        return this.printNodeCommentsIfAny(node, identation, whileStm);\n    }\n\n    printForStatement(node, identation) {\n        const initializer = this.printNode(node.initializer, 0);\n        const condition = this.printNode(node.condition, 0);\n        const incrementor = this.printNode(node.incrementor, 0);\n\n        const forStm = this.getIden(identation) +\n                this.FOR_TOKEN + \" \" +\n                this.CONDITION_OPENING +\n                initializer + \"; \" + condition + \"; \" + incrementor +\n                this.CONDITION_CLOSE +\n                this.printBlock(node.statement, identation);\n        return this.printNodeCommentsIfAny(node, identation, forStm);\n    }\n\n    printBreakStatement(node, identation) {\n        const breakStm = this.getIden(identation) + this.BREAK_TOKEN + this.LINE_TERMINATOR;\n        return this.printNodeCommentsIfAny(node, identation, breakStm);\n    }\n\n    printPostFixUnaryExpression(node, identation) {\n        const {operand, operator} = node;\n        return this.getIden(identation) + this.printNode(operand, 0) + this.PostFixOperators[operator];\n    }\n\n    printPrefixUnaryExpression(node, identation) {\n        const {operand, operator} = node;\n        if (operator === ts.SyntaxKind.ExclamationToken) {\n            // not branch check falsy/turthy values if needed;\n            return this.getIden(identation) + this.PrefixFixOperators[operator] + this.printCondition(node.operand, 0);\n        }\n        return this.getIden(identation) + this.PrefixFixOperators[operator] + this.printNode(operand, 0);\n    }\n\n    printObjectLiteralBody(node, identation) {\n        let body =  node.properties.map((p) => this.printNode(p, identation+1)).join(\",\\n\");\n        body = body ? body + \",\" : body;\n        return body;\n    }\n\n    printObjectLiteralExpression(node, identation) {\n\n        const objectBody = this.printObjectLiteralBody(node, identation);\n        const formattedObjectBody = objectBody ? \"\\n\" + objectBody + \"\\n\" + this.getIden(identation) : objectBody;\n        return  this.OBJECT_OPENING + formattedObjectBody + this.OBJECT_CLOSING;\n    }\n\n    printCustomRightSidePropertyAssignment(node, identation): string {\n        return undefined; // stub to override\n    }\n\n    printPropertyAssignment(node, identation) {\n        const {name, initializer} = node;\n        const nameAsString = this.printNode(name, 0);\n\n        const customRightSide = this.printCustomRightSidePropertyAssignment(initializer, identation);\n\n        const valueAsString = customRightSide ? customRightSide : this.printNode(initializer, identation);\n\n        let trailingComment = this.printTraillingComment(node, identation);\n        trailingComment = trailingComment ? \" \" + trailingComment : trailingComment;\n\n        const propOpen = this.PROPERTY_ASSIGNMENT_OPEN ? this.PROPERTY_ASSIGNMENT_OPEN  + \" \": \"\";\n        const propClose = this.PROPERTY_ASSIGNMENT_CLOSE ? \" \" + this.PROPERTY_ASSIGNMENT_CLOSE : \"\";\n\n        return this.getIden(identation) +\n                propOpen +\n                nameAsString +\n                this.PROPERTY_ASSIGNMENT_TOKEN + \" \" +\n                valueAsString.trim() +\n                propClose +\n                trailingComment;\n    }\n\n    printElementAccessExpressionExceptionIfAny(node) {\n        return undefined; // stub to override\n    }\n\n    printElementAccessExpression(node, identation) {\n        // example x['test']\n        const {expression, argumentExpression} = node;\n\n        const exception = this.printElementAccessExpressionExceptionIfAny(node);\n        if (exception) {\n            return exception;\n        }\n\n        // when we want replace x['test'] with getValue(x, 'test') only when in the left side\n        // Examples:\n        // x[\"a\"] = x[\"b\"] : binary expression\n        // const a = x[\"b\"] : variable declaration\n        const isLeftSideOfAssignment = node.parent?.kind === ts.SyntaxKind.BinaryExpression &&\n                            (node.parent.operatorToken.kind === ts.SyntaxKind.EqualsToken || node.parent.operatorToken.kind === ts.SyntaxKind.PlusEqualsToken) &&\n                            node.parent?.left === node;\n        // to do; check nested accesses\n        // const newNode = node.parent;\n        // we need this loop because we might have x[\"t\"][\"test\"][\"key\"]\n        // so the parent of the node might be another ElementAccessExpression and not the binary expression/variable declaration directly\n        // to do\n        // while (newNode !== undefined && newNode.kind !== ts.SyntaxKind.BinaryExpression) {\n        //     if (newNode.right === node) {\n        //         rightSideOfAssignment = true;\n        //         break;\n        //     }\n        //     newNode = newNode.parent;\n        // }\n\n        const expressionAsString = this.printNode(expression, 0);\n        const argumentAsString = this.printNode(argumentExpression, 0);\n\n        // c# only\n        if (!isLeftSideOfAssignment && this.ELEMENT_ACCESS_WRAPPER_OPEN && this.ELEMENT_ACCESS_WRAPPER_CLOSE) {\n            return `${this.ELEMENT_ACCESS_WRAPPER_OPEN}${expressionAsString}, ${argumentAsString}${this.ELEMENT_ACCESS_WRAPPER_CLOSE}`;\n        }\n        // cast order[\"test\"] to ((Dictionariy<string, object>)order)[\"test\"] or List<object>\n        if (isLeftSideOfAssignment && this.ELEMENT_ACCESS_WRAPPER_OPEN && this.ELEMENT_ACCESS_WRAPPER_CLOSE) {\n            const type = global.checker.getTypeAtLocation(argumentExpression);\n            const isString = this.isStringType(type.flags);\n\n            let isUnionString = false; // handle unions later\n            if (type.flags === ts.TypeFlags.Union) {\n                isUnionString = this.isStringType(type?.types[0].flags);\n            }\n\n            if (isString || isUnionString || type.flags === ts.TypeFlags.Any) { // default to string when unknown\n                // to do refactor and move this to the derived classes\n                if (this.id === \"C#\") {\n                    const cast = ts.isStringLiteralLike(argumentExpression) ? \"\" : '(string)';\n                    return `((IDictionary<string,object>)${expressionAsString})[${cast}${argumentAsString}]`;\n                }\n                // if (this.id === \"Go\") {\n                //     return `AddElementToObject(${expressionAsString}, ${argumentAsString})`;\n                // }\n\n            }\n            return `((${this.ARRAY_KEYWORD})${expressionAsString})[Convert.ToInt32(${argumentAsString})]`;\n        }\n\n        return expressionAsString + \"[\" + argumentAsString + \"]\";\n    }\n\n    printCondition (node, identation) {\n\n        if (this.supportsFalsyOrTruthyValues) {\n            // languages like php or python do not need this extra logic\n            return this.printNode(node, identation);\n        }\n\n        // can be called from ifs or conditional expressions or binary expressions so might contain the ! operator\n        if (node.kind  === ts.SyntaxKind.PrefixUnaryExpression && node.operator === ts.SyntaxKind.ExclamationToken) {\n            return this.printPrefixUnaryExpression(node, identation); // avoid infinite recursion\n        }\n\n        let expression = this.printNode(node, 0);\n        // wrap falsy/truty expressions if needed\n        if ( (1+1) || (node.kind !== ts.SyntaxKind.BinaryExpression && node.kind !== ts.SyntaxKind.ParenthesizedExpression)) {\n\n            const typeFlags = global.checker.getTypeAtLocation(node).flags;\n            if ( (1+1) || typeFlags !== ts.TypeFlags.BooleanLiteral && typeFlags  !== ts.TypeFlags.Boolean) {\n                expression = this.printNode(node, 0);\n                // this.warn(node, node.getText(), \"Falsy/Truthy expressions are not supported by this language, so adding the defined wrapper!\");\n                expression = `${this.FALSY_WRAPPER_OPEN}${expression}${this.FALSY_WRAPPER_CLOSE}`;\n            }\n        }\n        return `${this.getIden(identation)}${expression}`; // stub to override\n    }\n\n\n    printIfStatement(node, identation) {\n\n        const expression = this.printCondition(node.expression, 0);\n\n        const elseExists = node.elseStatement !== undefined;\n        const isElseIf = node.parent.kind === ts.SyntaxKind.IfStatement;\n\n        const needChainBlock = elseExists;\n        const ifBody = this.printBlock(node.thenStatement, identation, needChainBlock);\n\n        let ifComplete = this.CONDITION_OPENING + expression + this.CONDITION_CLOSE + ifBody;\n        if (isElseIf) {\n            ifComplete = this.ELSEIF_TOKEN + \" \" + ifComplete;\n        } else {\n            ifComplete = this.getIden(identation) + this.IF_TOKEN + \" \" + ifComplete;\n        }\n\n        const elseStatement = node.elseStatement;\n        if (elseStatement?.kind === ts.SyntaxKind.Block) {\n\n            const elseBody = this.printBlock(elseStatement, identation);\n\n            const elseBlock = this.ELSE_TOKEN + elseBody;\n\n            ifComplete += elseBlock;\n\n        } else if (elseStatement?.kind === ts.SyntaxKind.IfStatement) {\n            const elseBody = this.printIfStatement(elseStatement, identation);\n            ifComplete += elseBody;\n        }\n        return this.printNodeCommentsIfAny(node, identation, ifComplete);\n    }\n\n    printParenthesizedExpression(node, identation) {\n        if (node.expression.kind === ts.SyntaxKind.AsExpression) {\n            // transform (this as any) into this, () and as any are not necessary\n            return this.getIden(identation) + this.printNode(node.expression, 0);\n        }\n        return this.getIden(identation) + this.LEFT_PARENTHESIS + this.printNode(node.expression, 0) + this.RIGHT_PARENTHESIS;\n    }\n\n    printBooleanLiteral(node) {\n        if (ts.SyntaxKind.TrueKeyword === node.kind) {\n            return this.TRUE_KEYWORD;\n        }\n        return this.FALSE_KEYWORD;\n    }\n\n    printTryStatement(node, identation) {\n        const tryBody = this.printBlock(node.tryBlock, identation, true);\n\n        const catchBody = this.printBlock(node.catchClause.block, identation);\n        const catchDeclaration = this.CATCH_DECLARATION + \" \" + this.printNode(node.catchClause.variableDeclaration.name, 0);\n\n        const catchCondOpen = this.CONDITION_OPENING ? this.CONDITION_OPENING : \" \";\n\n        return this.getIden(identation) + this.TRY_TOKEN +\n                            tryBody +\n                            this.CATCH_TOKEN + catchCondOpen + catchDeclaration + this.CONDITION_CLOSE +\n                            catchBody;\n    }\n\n    printNewExpression(node, identation) {\n        let expression = node.expression?.escapedText;\n        expression = expression ? expression : this.printNode(node.expression); // new Exception or new exact[string] check this out\n        const args = node.arguments.map(n => this.printNode(n, identation)).join(\", \");\n        const newToken = this.NEW_TOKEN ? this.NEW_TOKEN + \" \" : \"\";\n        return newToken + expression + this.LEFT_PARENTHESIS + args + this.RIGHT_PARENTHESIS;\n    }\n\n    printThrowStatement(node, identation) {\n        const expression = this.printNode(node.expression, 0);\n        return this.getIden(identation) + this.THROW_TOKEN + \" \" + expression + this.LINE_TERMINATOR;\n    }\n\n    printAwaitExpression(node, identation) {\n        const expression = this.printNode(node.expression, identation);\n        const awaitToken = this.asyncTranspiling ? this.AWAIT_TOKEN + \" \" : \"\";\n        return awaitToken + expression;\n    }\n\n    printConditionalExpression(node, identation) {\n        const condition = this.printCondition(node.condition, identation);\n        const whenTrue = this.printNode(node.whenTrue, 0);\n        const whenFalse = this.printNode(node.whenFalse, 0);\n\n        return condition + \" ? \" + whenTrue + \" : \" + whenFalse;\n    }\n\n    printAsExpression(node, identation) {\n        return this.printNode(node.expression, identation);\n    }\n\n    getFunctionNodeFromReturn(node) {\n        let parent = node.parent;\n        while (parent) {\n            if (parent.kind === ts.SyntaxKind.FunctionDeclaration || parent.kind === ts.SyntaxKind.MethodDeclaration) {\n                return parent;\n            }\n            parent = parent.parent;\n        }\n        return undefined;\n    }\n\n\n    printReturnStatement(node, identation) {\n        const leadingComment = this.printLeadingComments(node, identation);\n        let trailingComment = this.printTraillingComment(node, identation);\n        trailingComment = trailingComment ? \" \" + trailingComment : trailingComment;\n        const exp =  node.expression;\n        let rightPart = exp ? (' ' + this.printNode(exp, identation)) : '';\n        rightPart = rightPart.trim();\n\n        // cast return type if needed\n        // if (false && this.requiresCallExpressionCast) {\n        //     const functionNode = this.getFunctionNodeFromReturn(node);\n        //     let functionType = this.getFunctionType(functionNode, false);\n        //     if (functionType === undefined) {\n        //         // check the parent method type if any\n        //         const overrideMethod = this.getMethodOverride(functionNode);\n        //         if (overrideMethod !== undefined) {\n        //             functionType = this.getFunctionType(overrideMethod, false);\n        //         }\n        //     }\n        //     if (functionType && exp?.kind !== ts.SyntaxKind.UndefinedKeyword) {\n        //         rightPart = rightPart ? ' ' + `((${functionType}) (${rightPart}))` + this.LINE_TERMINATOR : this.LINE_TERMINATOR;\n        //         return leadingComment + this.getIden(identation) + this.RETURN_TOKEN + rightPart + trailingComment;\n        //     }\n        // }\n        rightPart = rightPart ? ' ' + rightPart + this.LINE_TERMINATOR : this.LINE_TERMINATOR;\n        return leadingComment + this.getIden(identation) + this.RETURN_TOKEN + rightPart + trailingComment;\n    }\n\n    printArrayBindingPattern(node, identation) {\n        const elements = node.elements.map((e) => this.printNode(e.name, identation)).join(\", \");\n        return this.getIden(identation) + this.ARRAY_OPENING_TOKEN + elements + this.ARRAY_CLOSING_TOKEN;\n    }\n\n    printBlock(node, identation, chainBlock = false) {\n        const blockOpen = this.getBlockOpen(identation);\n        const blockClose = this.getBlockClose(identation, chainBlock);\n        const statements = node.statements.map((s) => this.printNode(s, identation+1)).join(\"\\n\");\n\n        return blockOpen + statements + blockClose;\n    }\n\n    printExpressionStatement(node, identation) {\n        if (this.isCJSModuleExportsExpressionStatement(node)) {\n            return \"\"; // remove module.exports = ...\n        }\n        const exprStm = this.printNode(node.expression, identation);\n\n        // skip empty statements\n        if (exprStm.length === 0) {\n            return \"\";\n        }\n        const expStatement = this.getIden(identation) + exprStm + this.LINE_TERMINATOR;\n        return this.printNodeCommentsIfAny(node, identation, expStatement);\n    }\n\n    printPropertyDeclaration(node, identation) {\n        const modifiers = this.printPropertyAccessModifiers(node);\n        const name = this.printNode(node.name, 0);\n        if (node.initializer) {\n            const initializer = this.printNode(node.initializer, 0);\n            return this.getIden(identation) + modifiers + name + \" = \" + initializer + this.LINE_TERMINATOR;\n        }\n        return this.getIden(identation) + modifiers + name + this.LINE_TERMINATOR;\n    }\n\n    printPropertyAccessModifiers (node) {\n        let modifiers = this.printModifiers(node);\n        modifiers = modifiers ? modifiers + \" \" : modifiers;\n        return modifiers;\n    }\n\n    printSpreadElement(node, identation) {\n        const expression = this.printNode(node.expression, 0);\n        return this.getIden(identation) + this.SPREAD_TOKEN + expression;\n    }\n\n    printNullKeyword(node, identation){\n        return this.getIden(identation) + this.NULL_TOKEN;\n    }\n\n    printContinueStatement(node, identation){\n        return this.getIden(identation) + this.CONTINUE_TOKEN + this.LINE_TERMINATOR;\n    }\n\n    printDeleteExpression (node, identation) {\n        return undefined;\n    }\n\n    printNode(node, identation = 0): string {\n\n        try {\n            if(ts.isExpressionStatement(node)) {\n                return this.printExpressionStatement(node, identation);\n            } else if(ts.isBlock(node)) {\n                return this.printBlock(node, identation);\n            } else if (ts.isFunctionDeclaration(node) || ts.isFunctionExpression(node) || ts.isArrowFunction(node)){\n                return this.printFunctionDeclaration(node, identation);\n            } else if (ts.isClassDeclaration(node)) {\n                return this.printClass(node, identation);\n            } else if (ts.isVariableStatement(node)) {\n                return this.printVariableStatement(node, identation);\n            } else if (ts.isMethodDeclaration(node)) {\n                return this.printMethodDeclaration(node, identation);\n            } else if (ts.isStringLiteral(node)) {\n                return this.printStringLiteral(node);\n            } else if (ts.isNumericLiteral(node)) {\n                return this.printNumericLiteral(node);\n            } else if (ts.isPropertyAccessExpression(node)) {\n                return this.printPropertyAccessExpression(node, identation);\n            } else if (ts.isArrayLiteralExpression(node)) {\n                return this.printArrayLiteralExpression(node, identation);\n            } else if (ts.isCallExpression(node)) {\n                return this.printCallExpression(node, identation);\n            } else if (ts.isWhileStatement(node)) {\n                return this.printWhileStatement(node, identation);\n            } else if (ts.isBinaryExpression(node)) {\n                return this.printBinaryExpression(node, identation);\n            } else if (ts.isBreakStatement(node)) {\n                return this.printBreakStatement(node, identation);\n            } else if (ts.isForStatement(node)) {\n                return this.printForStatement(node, identation);\n            } else if (ts.isPostfixUnaryExpression(node)) {\n                return this.printPostFixUnaryExpression(node, identation);\n            } else if (ts.isVariableDeclarationList(node)) {\n                return this.printVariableDeclarationList(node, identation); // statements are slightly different if inside a for\n            } else if (ts.isObjectLiteralExpression(node)) {\n                return this.printObjectLiteralExpression(node, identation);\n            } else if (ts.isPropertyAssignment(node)) {\n                return this.printPropertyAssignment(node, identation);\n            } else if (ts.isIdentifier(node)) {\n                return this.printIdentifier(node);\n            } else if (ts.isElementAccessExpression(node)) {\n                return this.printElementAccessExpression(node, identation);\n            } else if (ts.isIfStatement(node)) {\n                return this.printIfStatement(node, identation);\n            } else if (ts.isParenthesizedExpression(node)) {\n                return this.printParenthesizedExpression(node, identation);\n            } else if ((ts as any).isBooleanLiteral(node)) {\n                return this.printBooleanLiteral(node);\n            } else if (ts.SyntaxKind.ThisKeyword === node.kind) {\n                return this.THIS_TOKEN;\n            } else if (ts.SyntaxKind.SuperKeyword === node.kind) {\n                return this.SUPER_TOKEN;\n            }else if (ts.isTryStatement(node)){\n                return this.printTryStatement(node, identation);\n            } else if (ts.isPrefixUnaryExpression(node)) {\n                return this.printPrefixUnaryExpression(node, identation);\n            } else if (ts.isThrowStatement(node)) {\n                return this.printThrowStatement(node, identation);\n            } else if (ts.isNewExpression(node)) {\n                return this.printNewExpression(node, identation);\n            } else if (ts.isAwaitExpression(node)) {\n                return this.printAwaitExpression(node, identation);\n            } else if (ts.isConditionalExpression(node)) {\n                return this.printConditionalExpression(node, identation);\n            } else if (ts.isAsExpression(node)) {\n                return this.printAsExpression(node, identation);\n            } else if (ts.isReturnStatement(node)) {\n                return this.printReturnStatement(node, identation);\n            } else if (ts.isArrayBindingPattern(node)) {\n                return this.printArrayBindingPattern(node, identation);\n            } else if (ts.isParameter(node)) {\n                return this.printParameter(node);\n            } else if (ts.isConstructorDeclaration(node)) {\n                return this.printConstructorDeclaration(node, identation);\n            } else if (ts.isPropertyDeclaration(node)) {\n                return this.printPropertyDeclaration(node, identation);\n            } else if (ts.isSpreadElement(node)) {\n                return this.printSpreadElement(node, identation);\n            } else if (ts.SyntaxKind.NullKeyword === node.kind) {\n                return this.printNullKeyword(node, identation);\n            } else if (ts.isContinueStatement(node)) {\n                return this.printContinueStatement(node, identation);\n            } else if (ts.isDeleteExpression(node)) {\n                return this.printDeleteExpression(node, identation);\n            }\n\n            if (node.statements) {\n                const transformedStatements = node.statements.map((m)=> {\n                    return this.printNode(m, identation + 1);\n                });\n\n                return transformedStatements.filter(st => st.length > 0 ).join(\"\\n\" + \"\\n\".repeat(this.LINES_BETWEEN_FILE_MEMBERS)) + \"\\n\".repeat(this.NUM_LINES_END_FILE);\n            }\n            return \"\";\n\n        } catch (e) {\n            throw new TranspilationError(this.id, e.messageText, node.getFullText(), node.pos, node.end);\n        }\n    }\n\n    getFileESMImports(node): IFileImport[] {\n        const result = [];\n        const importStatements = node.statements.filter((s) => ts.isImportDeclaration(s));\n        importStatements.forEach(node => {\n            const importPath = node.moduleSpecifier.text;\n            const importClause = node.importClause;\n            const namedImports = importClause.namedBindings;\n            if (namedImports) {\n                if (namedImports.elements) {\n                    // named imports\n                    namedImports.elements.forEach((elem) => {\n                        const name = elem.name.text;\n                        const fileImport: IFileImport = {\n                            name,\n                            path: importPath,\n                            isDefault: false\n                        };\n                        result.push(fileImport);\n                    });\n                } else {\n                    // namespace import (import * as name from 'path')\n                    const name = namedImports.name.escapedText;\n                    const fileImport: IFileImport = {\n                        name,\n                        path: importPath,\n                        isDefault: false\n                    };\n                    result.push(fileImport);\n                }\n\n            } else {\n                // default import\n                const name = importClause.name.text;\n                const fileImport: IFileImport = {\n                    name,\n                    path: importPath,\n                    isDefault: true\n                };\n                result.push(fileImport);\n            }\n        });\n        return result;\n    }\n\n    isCJSRequireStatement(node): boolean {\n        const dec = node.declarationList.declarations[0];\n        return dec.initializer && ts.isCallExpression(dec.initializer) && dec.initializer.expression.getText() === \"require\";\n    }\n\n    isCJSModuleExportsExpressionStatement(node): boolean {\n        if (node.expression && node.expression.kind === ts.SyntaxKind.BinaryExpression ) {\n            if (node.expression.left.kind === ts.SyntaxKind.PropertyAccessExpression) {\n                const left = node.expression.left as ts.PropertyAccessExpression;\n                return left.expression.getText() === \"module\" && left.name.getText() === \"exports\";\n            }\n        }\n        return false;\n    }\n\n    getCJSImports(node): IFileImport[] {\n        const result = [];\n        const varStatements = node.statements.filter(s => ts.isVariableStatement(s));\n        const decList = varStatements.map(s => s.declarationList);\n        const dec = decList.map(d => d.declarations[0]);\n\n        dec.forEach(decNode => {\n            if (decNode.initializer && decNode.initializer.kind === ts.SyntaxKind.CallExpression) {\n                const callExpression = decNode.initializer.expression.getText();\n                if (callExpression === \"require\") {\n                    const isDefault = decNode.name.kind === ts.SyntaxKind.Identifier;\n                    const importPath = decNode.initializer.arguments[0].text;\n                    if (isDefault) {\n                        const name = decNode.name.text;\n                        const fileImport: IFileImport = {\n                            name,\n                            path: importPath,\n                            isDefault: isDefault\n                        };\n                        result.push(fileImport);\n                    } else {\n                        const elems = decNode.name.elements;\n                        elems.forEach(elem => {\n                            const name = elem.name.text;\n                            const fileImport: IFileImport = {\n                                name,\n                                path: importPath,\n                                isDefault: false,\n                            };\n                            result.push(fileImport);\n                        });\n                    }\n                }\n            }\n        });\n\n        return result;\n    }\n\n    getFileImports(node): IFileImport[] {\n        const esmImports = this.getFileESMImports(node);\n        if (esmImports.length > 0) {\n            return esmImports;\n        }\n        const cjsImports = this.getCJSImports(node);\n        return cjsImports;\n    }\n\n    getESMExports(node): IFileExport[] {\n        const result = [];\n        const namedExports = node.statements.filter((s) => ts.isExportDeclaration(s));\n        const defaultExport = node.statements.filter((s) => ts.isExportAssignment(s));\n\n        namedExports.forEach(node => {\n            const namedExports = node.exportClause;\n            if (namedExports) {\n                namedExports.elements.forEach((elem) => {\n                    const name = elem.name.text;\n                    const fileExport: IFileExport = {\n                        name,\n                        isDefault: false\n                    };\n                    result.push(fileExport);\n                });\n            }\n        });\n\n        defaultExport.forEach(node => {\n            const name = node.expression.getText();\n            const fileExport: IFileExport = {\n                name,\n                isDefault: true\n            };\n            result.push(fileExport);\n        });\n        return result;\n    }\n\n    getCJSExports(node): IFileExport[] {\n        const result = [];\n        const moduleExports = node.statements.filter(s => this.isCJSModuleExportsExpressionStatement(s)).map(s => s.expression as ts.BinaryExpression);\n\n        moduleExports.forEach(node => {\n            const right = node.right;\n            if (right.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n                const props = right.properties;\n                props.forEach(prop => {\n                    const name = prop.name.getText();\n                    const fileExport: IFileExport = {\n                        name,\n                        isDefault: false\n                    };\n                    result.push(fileExport);\n                });\n            }\n            if (right.kind === ts.SyntaxKind.Identifier) {\n                const name = right.getText();\n                const fileExport: IFileExport = {\n                    name,\n                    isDefault: true\n                };\n                result.push(fileExport);\n            }\n        });\n        return result;\n    }\n\n    getExportDeclarations(node): IFileExport[] {\n        // example export default class X\n        const result = [];\n        const classDeclarations = node.statements.filter((s) => ts.isClassDeclaration(s));\n        const functionDeclarations = node.statements.filter((s) => ts.isFunctionDeclaration(s));\n\n        const both = classDeclarations.concat(functionDeclarations);\n        both.forEach(classNode => {\n            const modifiers = classNode.modifiers;\n            if (modifiers) {\n                const isDefault = modifiers.some((m) => m.kind === ts.SyntaxKind.DefaultKeyword);\n                if (isDefault) {\n                    const name = classNode.name.text;\n                    const fileExport: IFileExport = {\n                        name,\n                        isDefault: true\n                    };\n                    result.push(fileExport);\n                }\n            }\n        });\n        return result;\n    }\n\n    getFileExports(node): IFileExport[] {\n        const defaultClassAndFunctionsExports = this.getExportDeclarations(node);\n        const esmExports = this.getESMExports(node).concat(defaultClassAndFunctionsExports);\n        if (esmExports.length > 0) {\n            return esmExports;\n        }\n        return this.getCJSExports(node);\n    }\n\n    getReturnTypeFromMethod(node): string {\n        // first try custom type\n\n        const bType = global.checker.getTypeAtLocation(node);\n        // const func2Symbol = bType.getProperty(\"test1\")!;\n        const func2Type = global.checker.getTypeOfSymbolAtLocation(bType.symbol, bType.symbol.valueDeclaration);\n        const func2Signature = global.checker.getSignaturesOfType(func2Type, ts.SignatureKind.Call)[0];\n        const rawType = func2Signature.getReturnType();\n        // const parsed = ts.TypeFlags[rawType.flags];\n        // console.log(parsed);\n        const res = global.checker.typeToString(rawType); // C\n        if (res === undefined) {\n            const name = node.type?.typeName?.escapedText;\n            if (name){\n                return name as string;\n            }\n        }\n        return res;\n    }\n\n    getParameterType(node): IParameterType {\n        const isOptional = node.questionToken !== undefined;\n\n        const result: IParameterType = {\n            name: node.name.getText(),\n            isOptional: isOptional,\n            type: undefined\n        };\n\n        if (node.initializer !== undefined) {\n            result.initializer = node.initializer.getText();\n        }\n\n        // first try custom type\n        if (node.type === undefined) {\n            // does not have a type or uses a initializer\n            if (node.initializer !== undefined) {\n                const type = global.checker.getTypeAtLocation(node.initializer);\n                const res = global.checker.typeToString(type); // C\n                // console.log(\"initializer\", res);\n                // result.initializer = node.initializer.text;\n                result.type = ts.TypeFlags[type.flags];\n                return result;\n            }\n        }\n\n        const name = node.type?.typeName?.escapedText;\n        if (name){\n            result.type = name as string;\n            if (node.initializer !== undefined) {\n                result.initializer = node.initializer.text;\n            }\n            return result;\n        }\n\n        if (node.type != undefined) {\n            const type = global.checker.getTypeAtLocation(node.type);\n            const res = global.checker.typeToString(type); // C\n            result.type = res as string;\n            return result;\n        }\n        return result;\n    }\n\n    getMethodTypes(file): IMethodType[] {\n        const result: IMethodType[] = [];\n        if (!file.statements) {\n            return result;\n        }\n        const classDeclarations = file.statements.filter((s) => ts.isClassDeclaration(s));\n        classDeclarations.forEach((node) => {\n            const methods = node.members.filter((m) => ts.isMethodDeclaration(m));\n            methods.forEach(m => {\n                const isAsync = this.isAsyncFunction(m);\n                const name = m.name.getText();\n                const returnType = this.getReturnTypeFromMethod(m);\n                const parameters = (m as any).parameters;\n                // const paramTypes:IParameterType[] = parameters.map((p) => this.getParameterType(p));\n                const paramTypes:IParameterType[] = [];\n                parameters.forEach((p) => {\n                    const res = this.getParameterType(p);\n                    paramTypes.push(res);\n                });\n                result.push({\n                    name,\n                    async:isAsync,\n                    returnType,\n                    parameters: paramTypes\n                });\n            });\n        });\n\n        return result;\n    }\n}\n\nexport {\n    BaseTranspiler\n};\n","\ninterface IInput {\n    language: Languages;\n    async: boolean;\n}\n\n\ninterface IParameterType {\n    name: string;\n    type: string;\n    isOptional: boolean;\n    initializer?: string;\n}\n\ninterface IMethodType {\n    async: boolean;\n    name: string;\n    returnType: string;\n    parameters: IParameterType[];\n}\n\ninterface IFileImport {\n    name: string;\n    path: string;\n    isDefault: boolean;\n}\n\ninterface IFileExport {\n    name: string;\n    isDefault: boolean;\n}\n\ninterface ITranspiledFile {\n    content: string;\n    imports: IFileImport[];\n    exports: IFileExport[];\n    methodsTypes?: IMethodType[];\n}\n\nenum Languages {\n    Python,\n    Php,\n    CSharp,\n    Go\n}\n\nenum TranspilationMode {\n    ByPath,\n    ByContent\n}\n\n// const TranspilingError = (message) => ({\n//     error: new Error(message),\n//     code: 'TRANSPILING ERROR'\n// });\n\nclass TranspilationError extends Error {\n    constructor (id, message, nodeText, start, end) {\n        const parsedMessage = `Lang: ${id} Error: ${message} at ${start}:${end} node: \"${nodeText}\"`;\n        super (parsedMessage);\n        this.name = 'TranspilationError';\n\n    }\n}\n\n// class FunctionReturnTypeError extends TranspilationError {\n//     constructor (message) {\n//         super (message);\n//         this.name = 'FuctionReturnTypeError';\n//     }\n// }\n\n// class FunctionArgumentTypeError extends TranspilationError {\n//     constructor (message) {\n//         super (message);\n//         this.name = 'FunctionArgumentTypeError';\n//     }\n// }\n\nexport {\n    Languages,\n    TranspilationMode,\n    IFileImport,\n    ITranspiledFile,\n    IFileExport,\n    TranspilationError,\n    // FunctionReturnTypeError,\n    // FunctionArgumentTypeError,\n    IInput,\n    IMethodType,\n    IParameterType\n};","\n\nfunction regexAll (text: string, array: any[]): string {\n    for (const i in array) {\n        let regex = array[i][0];\n        const flags = (typeof regex === 'string') ? 'g' : undefined;\n        regex = new RegExp (regex, flags);\n        text = text.replace (regex, array[i][1]);\n    }\n    return text;\n}\n\nfunction unCamelCase (s: string): string | undefined {\n    return s.match (/[A-Z]/) ? s.replace (/[a-z0-9][A-Z]/g, x => x[0] + '_' + x[1]).replace(/[A-Z0-9][A-Z0-9][a-z][^$]/g, x => x[0] + '_' + x[1] + x[2] + x[3]).replace(/[a-z][0-9]$/g, x=> x[0] + '_' + x[1]).toLowerCase () : undefined;\n}\n\n// function extend (...args) {\n//     Object.assign ({}, ...args);\n// }\n\nexport {\n    regexAll,\n    unCamelCase,\n};\n","import { green, yellow, red } from \"colorette\";\n\nclass Logger {\n    static verbose = true;\n\n    // static createInstanceIfNeeded(): void {\n    //     if (!this._instance) {\n    //         this._instance = new Logger();\n    //       }\n    // }\n\n    static setVerboseMode(verbose: boolean) {\n        this.verbose = verbose;\n    }\n\n    static log(message: string) {\n        if (this.verbose) {\n            console.log(message);\n        }\n    }\n\n    static success(message: string) {\n        this.log(green(`[SUCCESS]: ${message}`));\n    }\n\n    static warning(message: string) {\n        this.log(yellow(`[WARNING]: ${message}`));\n    }\n\n    static error(message: string) {\n        this.log(red(`[ERROR]: ${message}`));\n    }\n}\n\nexport {\n    Logger\n};\n\n","import { BaseTranspiler } from \"./baseTranspiler.js\";\nimport ts, { TypeChecker } from 'typescript';\nimport { unCamelCase, regexAll } from \"./utils.js\";\nimport { Logger } from \"./logger.js\";\n\nconst SyntaxKind = ts.SyntaxKind;\n\nconst parserConfig = {\n    'ELSEIF_TOKEN': 'elseif',\n    'THIS_TOKEN': '$this',\n    'PROPERTY_ACCESS_TOKEN': '->',\n    'UNDEFINED_TOKEN': 'null',\n    'NOT_TOKEN': '!',\n    'LINE_TERMINATOR': ';',\n    'ARRAY_OPENING_TOKEN':\"[\",\n    'ARRAY_CLOSING_TOKEN':\"]\",\n    'OBJECT_OPENING':\"array(\",\n    'OBJECT_CLOSING':\")\",\n    'FUNCTION_TOKEN': 'function',\n    'ASYNC_TOKEN': '',\n    'PROPERTY_ASSIGNMENT_TOKEN': ' =>',\n    'NEW_TOKEN': 'new',\n    'THROW_TOKEN': 'throw',\n    'SUPER_TOKEN': 'parent',\n    'CONSTRUCTOR_TOKEN': 'function __construct',\n    'SUPER_CALL_TOKEN': 'parent::__construct',\n    'CATCH_DECLARATION': 'Exception',\n    'CATCH_TOKEN': 'catch',\n    'BLOCK_OPENING_TOKEN' :'{',\n    'BLOCK_CLOSING_TOKEN' :'}',\n    'CONDITION_OPENING' :'(',\n    'CONDITION_CLOSE' :')',\n    'PLUS_PLUS_TOKEN': '++',\n    'MINUS_MINUS_TOKEN': '--',\n    'SPACE_DEFAULT_PARAM': ' ',\n    'EXCLAMATION_EQUALS_EQUALS_TOKEN': '!==',\n    'EQUALS_EQUALS_EQUALS_TOKEN': '===',\n    'STRING_QUOTE_TOKEN': '\\'',\n    'EXTENDS_TOKEN': 'extends',\n};\n\nexport class PhpTranspiler extends BaseTranspiler {\n    awaitWrapper;\n    propRequiresScopeResolutionOperator: string[];\n    AWAIT_WRAPPER_OPEN;\n    AWAIT_WRAPPER_CLOSE;\n    ASYNC_FUNCTION_WRAPPER_OPEN = \"\";\n    constructor(config = {}) {\n\n        config['parser'] = Object.assign ({}, parserConfig, config['parser'] ?? {});\n\n        super(config);\n        this.id = \"php\";\n        this.asyncTranspiling = config['async'] ?? true;\n        this.uncamelcaseIdentifiers = config['uncamelcaseIdentifiers'] ?? false;\n        this.removeVariableDeclarationForFunctionExpression = config['removeFunctionAssignToVariable'] ?? false;\n        this.includeFunctionNameInFunctionExpressionDeclaration = config['includeFunctionNameInFunctionExpressionDeclaration'] ?? false;\n\n        this.propRequiresScopeResolutionOperator = ['super'] + (config['ScopeResolutionProps'] ?? []);\n\n        this.initConfig();\n\n        // user overrides\n        this.applyUserOverrides(config);\n\n        // const propertyAccessRemoval = config['PropertyAccessRequiresParenthesisRemoval'] ?? [];\n        // this.PropertyAccessRequiresParenthesisRemoval.push(...propertyAccessRemoval);\n\n        this.AWAIT_WRAPPER_OPEN = config['AWAIT_WRAPPER_OPEN'] ?? \"Async\\\\await(\";\n        this.AWAIT_WRAPPER_CLOSE = config['AWAIT_WRAPPER_CLOSE'] ??  \")\";\n    }\n\n    printAwaitExpression(node, identation) {\n        const expression = this.printNode(node.expression, identation);\n\n        if (!this.asyncTranspiling) {\n            return expression;\n        }\n\n        return this.AWAIT_WRAPPER_OPEN + expression + this.AWAIT_WRAPPER_CLOSE;\n    }\n\n    transformIdentifier(node, identifier) {\n        if (this.uncamelcaseIdentifiers) {\n            identifier = this.unCamelCaseIfNeeded(identifier);\n        }\n\n        // Get the symbol for the identifier\n        const symbol = global.checker.getSymbolAtLocation(node);\n\n        // Check if the symbol references a function declaration or expression\n        if (symbol && symbol.valueDeclaration) {\n            const valueDecl = symbol.valueDeclaration;\n\n            // Check if it's a function (FunctionDeclaration, FunctionExpression, ArrowFunction)\n            if (ts.isFunctionDeclaration(valueDecl) || ts.isFunctionExpression(valueDecl) || ts.isArrowFunction(valueDecl)) {\n                // Check if the identifier is passed as an argument in a function call\n                if (node.parent && ts.isCallExpression(node.parent) && node.parent.arguments.includes(node)) {\n                    return `'${identifier}'`;  // Transpile function reference as string\n                }\n            }\n        }\n\n        // below is commented, due to : https://github.com/ccxt/ast-transpiler/pull/15\n        //\n        // If the identifier is a function parameter (callback), it should remain a variable with `$` prefix\n        // if (node.parent && (ts.isParameter(node.parent) || (ts.isCallExpression(node.parent) && ts.isIdentifier(node)))) {\n        //     return \"$\" + identifier;\n        // }\n\n        // Default case: prepend $ for variables (non-functions), unless it's a class or constant\n        if (!this.startsWithUpperCase(identifier)) {\n            return \"$\" + identifier;  // Prepend $ for variable names\n        }\n\n        return identifier;\n    }\n\n\n    getCustomOperatorIfAny(left, right, operator) {\n        const STRING_CONCAT = '.';\n        const PLUS_EQUALS_TOKEN = '.=';\n        if (operator.kind == SyntaxKind.PlusToken || operator.kind == SyntaxKind.PlusEqualsToken) {\n\n            const TOKEN = operator.kind == SyntaxKind.PlusToken ? STRING_CONCAT : PLUS_EQUALS_TOKEN;\n\n            if (left.kind == SyntaxKind.StringLiteral || right.kind == SyntaxKind.StringLiteral) {\n                return TOKEN;\n            }\n\n            const leftType = global.checker.getTypeAtLocation(left);\n            const rightType = global.checker.getTypeAtLocation(right);\n\n            if (leftType.flags === ts.TypeFlags.String || rightType.flags === ts.TypeFlags.String) {\n                return TOKEN;\n            }\n            if (leftType.flags === ts.TypeFlags.StringLiteral || rightType.flags === ts.TypeFlags.StringLiteral) {\n                return TOKEN;\n            }\n        }\n        return undefined;\n    }\n\n    printLengthProperty(node, identation, name = undefined) {\n        const leftSide = this.printNode(node.expression, 0);\n        const type = (global.checker as TypeChecker).getTypeAtLocation(node.expression); // eslint-disable-line\n        this.warnIfAnyType(node, type.flags, leftSide, \"length\");\n        return this.isStringType(type.flags) ? `strlen(${leftSide})` : `count(${leftSide})`;\n    }\n\n    printPopCall(node, identation, name = undefined) {\n        return `array_pop(${name})`;\n    }\n\n    printReverseCall(node, identation, name = undefined) {\n        return `${name} = array_reverse(${name})`;\n    }\n\n    printShiftCall(node, identation, name = undefined) {\n        return `array_shift(${name})`;\n    }\n\n    printToLowerCaseCall(node, identation, name = undefined) {\n        return `strtolower(${name})`;\n    }\n\n    printToUpperCaseCall(node, identation, name = undefined) {\n        return `strtoupper(${name})`;\n    }\n\n    printToStringCall(node, identation, name = undefined) {\n        return `((string) ${name})`;\n    }\n\n    printArrayIsArrayCall(node, identation, parsedArg = undefined) {\n        return `gettype(${parsedArg}) === 'array' && array_is_list(${parsedArg})`;\n    }\n\n    printObjectKeysCall(node, identation, parsedArg = undefined) {\n        return `is_array(${parsedArg}) ? array_keys(${parsedArg}) : array()`;\n    }\n\n    printObjectValuesCall(node, identation, parsedArg = undefined) {\n        return `is_array(${parsedArg}) ? array_values(${parsedArg}) : array()`;\n    }\n\n    printJsonParseCall(node, identation, parsedArg?) {\n        return `json_decode(${parsedArg}, $as_associative_array = true)`;\n    }\n\n    printJsonStringifyCall(node: any, identation: any, parsedArg?: any) {\n        return `json_encode(${parsedArg})`;\n    }\n\n    printArrayPushCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `${name}[] = ${parsedArg}`;\n    }\n\n    printPromiseAllCall(node, identation, parsedArg = undefined) {\n        return `Promise\\\\all(${parsedArg})`;\n    }\n\n    printMathCeilCall(node, identation, parsedArg = undefined) {\n        return `((int) ceil(${parsedArg}))`;\n    }\n\n    printNumberIsIntegerCall(node, identation, parsedArg?) {\n        return `is_int(${parsedArg})`;\n    }\n\n    printMathRoundCall(node, identation, parsedArg = undefined) {\n        return `((int) round(${parsedArg}))`;\n    }\n\n    printMathFloorCall(node: any, identation: any, parsedArg?: any) {\n        return `((int) floor(${parsedArg}))`;\n    }\n\n    printReplaceCall(node, identation, name = undefined, parsedArg = undefined, parsedArg2 = undefined) {\n        return `str_replace(${parsedArg}, ${parsedArg2}, ${name})`;\n    }\n\n    printReplaceAllCall(node, identation, name = undefined, parsedArg = undefined, parsedArg2 = undefined) {\n        return `str_replace(${parsedArg}, ${parsedArg2}, ${name})`;\n    }\n\n    printIncludesCall(node, identation, name = undefined, parsedArg = undefined) {\n        // \"ol\".includes(\"o\") -> str_contains(\"ol\", \"o\") or [12,3,4].includes(3) -> in_array(3, [12,3,4])\n        const leftSide = node.expression?.expression;\n        const leftSideText = this.printNode(leftSide, 0);\n        const type = global.checker.getTypeAtLocation(leftSide); // eslint-disable-line\n        this.warnIfAnyType(node, type.flags, leftSideText, \"includes\");\n        this.warnIfAnyType(node, type.flags, leftSideText, \"includes\");\n        if (this.isStringType(type.flags)) {\n            return `str_contains(${name}, ${parsedArg})`;\n        } else {\n            return `in_array(${parsedArg}, ${name})`;\n        }\n    }\n\n    printIndexOfCall(node, identation, name = undefined, parsedArg = undefined) {\n        const leftSide = node.expression?.expression;\n        const leftSideText = this.printNode(leftSide, 0);\n        const type = global.checker.getTypeAtLocation(leftSide); // eslint-disable-line\n        this.warnIfAnyType(node, type.flags, leftSideText, \"indexOf\");\n        if (this.isStringType(type.flags)) {\n            return `mb_strpos(${name}, ${parsedArg})`;\n        } else {\n            return `array_search(${parsedArg}, ${name})`;\n        }\n    }\n\n    printSearchCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `mb_strpos(${name}, ${parsedArg})`;\n    }\n\n    printStartsWithCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `str_starts_with(${name}, ${parsedArg})`;\n    }\n\n    printEndsWithCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `str_ends_with(${name}, ${parsedArg})`;\n    }\n\n    printTrimCall(node, identation, name = undefined) {\n        return `trim(${name})`;\n    }\n\n    printJoinCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `implode(${parsedArg}, ${name})`;\n    }\n\n    printSplitCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `explode(${parsedArg}, ${name})`;\n    }\n\n    printConcatCall(node: any, identation: any, name?: any, parsedArg?: any) {\n        return `array_merge(${name}, ${parsedArg})`;\n    }\n\n    printPadEndCall(node, identation, name, parsedArg, parsedArg2) {\n        return `str_pad(${name}, ${parsedArg}, ${parsedArg2}, STR_PAD_RIGHT)`;\n    }\n\n    printPadStartCall(node, identation, name, parsedArg, parsedArg2) {\n        return `str_pad(${name}, ${parsedArg}, ${parsedArg2}, STR_PAD_LEFT)`;\n    }\n\n    printDateNowCall(node, identation) {\n        return \"round(microtime(true) * 1000)\";\n    }\n\n    printInstanceOfExpression(node, identation) {\n        // const left = this.printNode(node.left, 0);\n        // const right = this.printNode(node.right, 0);\n        const left = node.left.escapedText;\n        const right = node.right.escapedText;\n        return this.getIden(identation) + \"$\"+left+\" instanceof \"+right+\"\";\n    }\n\n    printDeleteExpression(node, identation) {\n        const expression = this.printNode (node.expression, 0);\n        return `unset(${expression})`;\n    }\n\n    getExceptionalAccessTokenIfAny(node) {\n        const leftSide = node.expression.escapedText ?? node.expression.getFullText().trim();\n\n        if (!leftSide) {\n            return undefined;\n        }\n\n        if (this.propRequiresScopeResolutionOperator.includes(leftSide)) {\n            return \"::\";\n        }\n        return undefined;\n    }\n\n    handleTypeOfInsideBinaryExpression(node, identation) {\n        const left = node.left;\n        const right = node.right.text;\n        const op = node.operatorToken.kind;\n        const expression = left.expression;\n\n        const isDifferentOperator = op === SyntaxKind.ExclamationEqualsEqualsToken || op === SyntaxKind.ExclamationEqualsToken;\n        const notOperator = isDifferentOperator ? this.NOT_TOKEN : \"\";\n\n        const opComp = isDifferentOperator ? this.EXCLAMATION_EQUALS_EQUALS_TOKEN : this.EQUALS_EQUALS_EQUALS_TOKEN;\n\n        switch (right) {\n        case \"string\":\n            return this.getIden(identation) + notOperator + \"is_string(\" + this.printNode(expression, 0) + \")\";\n        case \"number\":\n            return this.getIden(identation) + notOperator + \"(is_int(\" + this.printNode(expression, 0) + \") || is_float(\" + this.printNode(expression, 0) + \"))\";\n        case \"boolean\":\n            return this.getIden(identation) + notOperator + \"is_bool(\" + this.printNode(expression, 0) + \")\";\n        case \"object\":\n            return this.getIden(identation) + notOperator + \"is_array(\" + this.printNode(expression, 0) + \")\";\n        case \"undefined\":\n            return this.getIden(identation) + this.printNode(expression, 0) + \" \" + opComp + \" null\";\n        }\n\n        return undefined;\n\n    }\n\n    printCustomBinaryExpressionIfAny(node, identation) {\n        const left = node.left;\n        const right = node.right.text;\n\n        const op = node.operatorToken.kind;\n\n        if (left.kind === SyntaxKind.TypeOfExpression) {\n            // handle typeof operator\n            // Example: typeof a === \"string\"\n            const typeOfExpression = this.handleTypeOfInsideBinaryExpression(node, identation);\n            if (typeOfExpression) {\n                return typeOfExpression;\n            }\n        }\n\n        if (op === ts.SyntaxKind.InKeyword) {\n            const rightSide = this.printNode(node.right, 0);\n            const leftSide = this.printNode(node.left, 0);\n            return `${this.getIden(identation)}is_array(${rightSide}) && array_key_exists(${leftSide}, ${rightSide})`;\n        }\n\n        const prop = node?.left?.expression?.name?.text;\n\n        if (prop) {\n            const args = left.arguments;\n            const parsedArg =  (args && args.length > 0) ? this.printNode(args[0], 0): undefined;\n            const leftSideOfIndexOf = left.expression.expression;  // myString in myString.indexOf\n            const leftSide = this.printNode(leftSideOfIndexOf, 0);\n            const rightType = global.checker.getTypeAtLocation(leftSideOfIndexOf); // type of myString in myString.indexOf (\"b\") >= 0;\n            switch(prop) {\n            case 'indexOf':\n                if (op === SyntaxKind.GreaterThanEqualsToken && right === '0') {\n                    this.warnIfAnyType(node, rightType.flags,leftSide, \"indexOf\");\n                    if (this.isStringType(rightType.flags)) {\n                        return this.getIden(identation) + \"mb_strpos(\" + leftSide + \", \" + parsedArg + \") !== false\";\n                    } else {\n                        return this.getIden(identation) + \"in_array(\" + parsedArg + \", \" + leftSide + \")\";\n                    }\n                }\n            }\n        }\n        return undefined;\n    }\n\n    printFunctionDeclaration(node, identation) {\n        let functionDef = this.printFunctionDefinition(node, identation);\n        const funcBody = this.printFunctionBody(node, identation);\n        functionDef += funcBody;\n\n        return this.printNodeCommentsIfAny(node, identation, functionDef);\n    }\n\n    printFunctionBody(node, identation) {\n\n        if (this.asyncTranspiling && this.isAsyncFunction(node)) {\n            const blockOpen = this.getBlockOpen(identation);\n            const blockClose = this.getBlockClose(identation);\n\n            const parsedArgs = node.parameters.map(param => this.printParameter(param, false)).join(\", \");\n            const params = parsedArgs ? \" use (\" + parsedArgs + \")\" : \"\";\n\n            const bodyStms = [...node.body.statements];\n            const firstBodyStm = this.printNode(bodyStms[0], identation+2);\n            bodyStms.shift();\n            const funcBody = bodyStms.map((s) => this.printNode(s, identation+2)).join(\"\\n\");\n\n            // reformat first comment\n            const bodyParts = firstBodyStm.split(\"\\n\");\n            const commentPart = bodyParts.filter(line => this.isComment(line));\n            const isComment = commentPart.length > 0;\n            let header = this.getIden(identation+1) +  \"return Async\\\\async(function ()\" + params + \" {\\n\";\n            if (isComment) {\n                const commentPartString = commentPart.map((c) => this.getIden(identation+1) + c.trim()).join(\"\\n\");\n                const firstStmNoComment = bodyParts.filter(line => !this.isComment(line)).join(\"\\n\");\n                header = commentPartString + \"\\n\" + header + firstStmNoComment + \"\\n\";\n            } else {\n                header += firstBodyStm + \"\\n\";\n            }\n\n            const result = header\n            + funcBody + \"\\n\"\n            + this.getIden(identation+1) + \"}) ();\";\n\n            return blockOpen + result + blockClose;\n        }\n        return super.printFunctionBody(node, identation);\n    }\n\n    printPropertyAccessModifiers(node) {\n        const modifiers = super.printPropertyAccessModifiers(node);\n        return modifiers ? modifiers : \"public \"; // default to public\n    }\n\n    transformLeadingComment(comment) {\n        const commentRegex = [\n            [ /\\{([\\]\\[\\|a-zA-Z0-9_-]+?)\\}/g, '~$1~' ], // eslint-disable-line -- resolve the \"arrays vs url params\" conflict (both are in {}-brackets)\n            [ /\\[([^\\]\\[]*)\\]\\{(@link .*)\\}/g, '~$2 $1~' ], // eslint-disable-line -- docstring item with link\n            [ /\\s+\\* @method/g, '' ], // docstring @method\n            [ /(\\s+)\\* @description (.*)/g, '$1\\* $2' ], // eslint-disable-line\n            [ /\\s+\\* @name .*/g, '' ], // docstring @name\n            [ /(\\s+)\\* @returns/g, '$1\\* @return' ], // eslint-disable-line\n            [ /\\~([\\]\\[\\|@\\.\\s+\\:\\/#\\-a-zA-Z0-9_-]+?)\\~/g, '{$1}' ], // eslint-disable-line -- resolve the \"arrays vs url params\" conflict (both are in {}-brackets)\n            [ /(\\s+ \\* @(param|return) {[^}]*)object([^}]*}.*)/g, '$1array$3' ], // docstring type conversion\n        ];\n\n        const transformed = regexAll(comment, commentRegex);\n\n        return transformed;\n    }\n\n    initConfig() {\n        this.LeftPropertyAccessReplacements = {\n            'this': '$this',\n        };\n\n        this.RightPropertyAccessReplacements = {\n\n        };\n\n        this.FullPropertyAccessReplacements = {\n            'Number.MAX_SAFE_INTEGER': 'PHP_INT_MAX',\n            'JSON.stringify': 'json_encode',\n            'console.log': 'var_dump',\n            'process.exit': 'exit',\n            'Math.log': 'log',\n            'Math.abs': 'abs',\n            'Math.floor': '(int) floor',\n            'Math.ceil': '(int) ceil',\n            'Math.round': '(int) round',\n            'Math.pow': 'pow',\n            'Math.min': 'min',\n            'Math.max': 'max',\n            // 'Promise.all': 'Promise\\\\all',\n        };\n\n        this.CallExpressionReplacements = {\n            'parseFloat': 'floatval',\n            'parseInt': 'intval',\n        };\n\n        this.PropertyAccessRequiresParenthesisRemoval = [\n            // 'length',\n            // 'toString',\n            // 'toUpperCase',\n            // 'toLowerCase',\n            // 'pop',\n            // 'reverse',\n            // 'shift',\n        ];\n    }\n\n}\n","import { BaseTranspiler } from \"./baseTranspiler.js\";\nimport ts, { TypeChecker } from 'typescript';\n\nconst parserConfig = {\n    'ELSEIF_TOKEN': 'else if',\n    'OBJECT_OPENING': 'new Dictionary<string, object>() {',\n    'ARRAY_OPENING_TOKEN': 'new List<object>() {',\n    'ARRAY_CLOSING_TOKEN': '}',\n    'PROPERTY_ASSIGNMENT_TOKEN': ',',\n    'VAR_TOKEN': 'object', // object\n    'METHOD_TOKEN': '',\n    'PROPERTY_ASSIGNMENT_OPEN': '{',\n    'PROPERTY_ASSIGNMENT_CLOSE': '}',\n    'SUPER_TOKEN': 'base',\n    'SUPER_CALL_TOKEN': 'base',\n    'FALSY_WRAPPER_OPEN': 'isTrue(',\n    'FALSY_WRAPPER_CLOSE': ')',\n    'COMPARISON_WRAPPER_OPEN' : \"isEqual(\",\n    'COMPARISON_WRAPPER_CLOSE' : \")\",\n    'UKNOWN_PROP_WRAPPER_OPEN': 'this.call(',\n    'UNKOWN_PROP_WRAPPER_CLOSE': ')',\n    'UKNOWN_PROP_ASYNC_WRAPPER_OPEN': 'this.callAsync(',\n    'UNKOWN_PROP_ASYNC_WRAPPER_CLOSE': ')',\n    'DYNAMIC_CALL_OPEN': 'callDynamically(',\n    'EQUALS_EQUALS_WRAPPER_OPEN': 'isEqual(',\n    'EQUALS_EQUALS_WRAPPER_CLOSE': ')',\n    'DIFFERENT_WRAPPER_OPEN': '!isEqual(',\n    'DIFFERENT_WRAPPER_CLOSE': ')',\n    'GREATER_THAN_WRAPPER_OPEN': 'isGreaterThan(',\n    'GREATER_THAN_WRAPPER_CLOSE': ')',\n    'GREATER_THAN_EQUALS_WRAPPER_OPEN': 'isGreaterThanOrEqual(',\n    'GREATER_THAN_EQUALS_WRAPPER_CLOSE': ')',\n    'LESS_THAN_WRAPPER_OPEN': 'isLessThan(',\n    'LESS_THAN_WRAPPER_CLOSE': ')',\n    'LESS_THAN_EQUALS_WRAPPER_OPEN': 'isLessThanOrEqual(',\n    'LESS_THAN_EQUALS_WRAPPER_CLOSE': ')',\n    'PLUS_WRAPPER_OPEN':'add(',\n    'PLUS_WRAPPER_CLOSE':')',\n    'MINUS_WRAPPER_OPEN':'subtract(',\n    'MINUS_WRAPPER_CLOSE':')',\n    'ARRAY_LENGTH_WRAPPER_OPEN': 'getArrayLength(',\n    'ARRAY_LENGTH_WRAPPER_CLOSE': ')',\n    'DIVIDE_WRAPPER_OPEN': 'divide(',\n    'DIVIDE_WRAPPER_CLOSE': ')',\n    'MULTIPLY_WRAPPER_OPEN': 'multiply(',\n    'MULTIPLY_WRAPPER_CLOSE': ')',\n    'INDEXOF_WRAPPER_OPEN': 'getIndexOf(',\n    'INDEXOF_WRAPPER_CLOSE': ')',\n    'MOD_WRAPPER_OPEN': 'mod(',\n    'MOD_WRAPPER_CLOSE': ')',\n    'FUNCTION_TOKEN': '',\n    'INFER_VAR_TYPE': false,\n    'INFER_ARG_TYPE': false,\n};\n\nexport class CSharpTranspiler extends BaseTranspiler {\n\n    binaryExpressionsWrappers;\n\n    constructor(config = {}) {\n        config['parser'] = Object.assign ({}, parserConfig, config['parser'] ?? {});\n\n        super(config);\n\n        this.requiresParameterType = true;\n        this.requiresReturnType = true;\n        this.asyncTranspiling = true;\n        this.supportsFalsyOrTruthyValues = false;\n        this.requiresCallExpressionCast = true;\n        this.id = \"C#\";\n\n\n        this.initConfig();\n\n        // user overrides\n        this.applyUserOverrides(config);\n    }\n\n    initConfig() {\n        this.LeftPropertyAccessReplacements = {\n            // 'this': '$this',\n        };\n\n        this.RightPropertyAccessReplacements = {\n            'push': 'Add', // list method\n            'indexOf': 'IndexOf', // list method\n            'toUpperCase': 'ToUpper',\n            'toLowerCase': 'ToLower',\n            'toString': 'ToString',\n        };\n\n        this.FullPropertyAccessReplacements = {\n            'JSON.parse': 'parseJson', // custom helper method\n            'console.log': 'Console.WriteLine',\n            'Number.MAX_SAFE_INTEGER': 'Int32.MaxValue',\n            'Math.min': 'Math.Min',\n            'Math.max': 'Math.Max',\n            'Math.log': 'Math.Log',\n            'Math.abs': 'Math.Abs',\n            // 'Math.ceil':  'Math.Ceiling', // need cast\n            // 'Math.round': 'Math.Round', // need to cast\n            'Math.floor': 'Math.Floor',\n            'Math.pow': 'Math.Pow',\n            // 'Promise.all': 'Task.WhenAll',\n        };\n\n        this.CallExpressionReplacements = {\n            // \"parseInt\": \"parseINt\",\n            // \"parseFloat\": \"float.Parse\",\n        };\n\n        this.ReservedKeywordsReplacements = {\n            'string': 'str',\n            'object': 'obj',\n            'params': 'parameters',\n            'base': 'bs',\n            'internal': 'intern',\n            'event': 'eventVar',\n            'fixed': 'fixedVar',\n        };\n\n        this.VariableTypeReplacements = {\n            'string': 'string',\n            'Str': 'string',\n            'number': 'double',\n            'Int': 'Int64',\n            'Num': 'double',\n            'Dict': 'Dictionary<string, object>',\n            'Strings': 'List<string>',\n            'List': 'List<object>',\n            'boolean': 'bool',\n        };\n\n        this.ArgTypeReplacements = {\n            'string': 'string',\n            'Str': 'string',\n            'number': 'double',\n            'Int': 'Int64',\n            'Num': 'double',\n            'Dict': 'Dictionary<string, object>',\n            'Strings': 'List<string>',\n            'List': 'List<object>',\n            'boolean': 'bool',\n        };\n\n        this.binaryExpressionsWrappers = {\n            [ts.SyntaxKind.EqualsEqualsToken]: [this.EQUALS_EQUALS_WRAPPER_OPEN, this.EQUALS_EQUALS_WRAPPER_CLOSE],\n            [ts.SyntaxKind.EqualsEqualsEqualsToken]: [this.EQUALS_EQUALS_WRAPPER_OPEN, this.EQUALS_EQUALS_WRAPPER_CLOSE],\n            [ts.SyntaxKind.ExclamationEqualsToken]: [this.DIFFERENT_WRAPPER_OPEN, this.DIFFERENT_WRAPPER_CLOSE],\n            [ts.SyntaxKind.ExclamationEqualsEqualsToken]: [this.DIFFERENT_WRAPPER_OPEN, this.DIFFERENT_WRAPPER_CLOSE],\n            [ts.SyntaxKind.GreaterThanToken]: [this.GREATER_THAN_WRAPPER_OPEN, this.GREATER_THAN_WRAPPER_CLOSE],\n            [ts.SyntaxKind.GreaterThanEqualsToken]: [this.GREATER_THAN_EQUALS_WRAPPER_OPEN, this.GREATER_THAN_EQUALS_WRAPPER_CLOSE],\n            [ts.SyntaxKind.LessThanToken]: [this.LESS_THAN_WRAPPER_OPEN, this.LESS_THAN_WRAPPER_CLOSE],\n            [ts.SyntaxKind.LessThanEqualsToken]: [this.LESS_THAN_EQUALS_WRAPPER_OPEN, this.LESS_THAN_EQUALS_WRAPPER_CLOSE],\n            [ts.SyntaxKind.PlusToken]: [this.PLUS_WRAPPER_OPEN, this.PLUS_WRAPPER_CLOSE],\n            [ts.SyntaxKind.MinusToken]: [this.MINUS_WRAPPER_OPEN, this.MINUS_WRAPPER_CLOSE],\n            [ts.SyntaxKind.AsteriskToken]: [this.MULTIPLY_WRAPPER_OPEN, this.MULTIPLY_WRAPPER_CLOSE],\n            [ts.SyntaxKind.PercentToken]: [this.MOD_WRAPPER_OPEN, this.MOD_WRAPPER_CLOSE],\n            [ts.SyntaxKind.SlashToken]: [this.DIVIDE_WRAPPER_OPEN, this.DIVIDE_WRAPPER_CLOSE],\n        };\n    }\n\n    getBlockOpen(identation){\n        return \"\\n\" + this.getIden(identation)  + this.BLOCK_OPENING_TOKEN + \"\\n\";\n    }\n\n    printSuperCallInsideConstructor(node, identation) {\n        return \"\"; // csharp does not need super call inside constructor\n    }\n\n    printIdentifier(node) {\n        let idValue = node.text ?? node.escapedText;\n\n        if (this.ReservedKeywordsReplacements[idValue]) {\n            idValue = this.ReservedKeywordsReplacements[idValue];\n        }\n\n        if (idValue === \"undefined\") {\n            return this.UNDEFINED_TOKEN;\n        }\n\n        // check if it is a class declaration that we need to wrap arounf typeof\n        // example: const x = Error -> var x = typeof(Error)\n        const type = global.checker.getTypeAtLocation(node);\n        const symbol = type?.symbol;\n        if (symbol !== undefined) {\n            // const declarations = global.checker.getDeclaredTypeOfSymbol(symbol).symbol?.declarations ?? [];\n            const decl = symbol?.declarations ?? [];\n            let isBuiltIn = undefined;\n            if (decl.length > 0) {\n                isBuiltIn = decl[0].getSourceFile().fileName.indexOf('typescript') > -1; //very hacky find a better solution later\n            }\n\n            if (isBuiltIn !== undefined && !isBuiltIn) {\n                // const isClassDeclaration = declarations.find(l => l.kind === ts.SyntaxKind.ClassDeclaration);\n                const isInsideNewExpression =  node?.parent?.kind === ts.SyntaxKind.NewExpression;\n                const isInsideCatch = node?.parent?.kind === ts.SyntaxKind.ThrowStatement;\n                const isLeftSide = node?.parent?.name === node || (node?.parent?.left === node);\n                const isCallOrPropertyAccess = node?.parent?.kind === ts.SyntaxKind.PropertyAccessExpression || node?.parent?.kind === ts.SyntaxKind.ElementAccessExpression;\n                if (!isLeftSide && !isCallOrPropertyAccess && !isInsideCatch && !isInsideNewExpression) {\n                    // return `typeof(${idValue})`; // this is not working as expected\n                    // for instance\n                    // const instance = new x();\n                    // const b = instance;\n                    // gets transpiled to\n                    // var instance = typeof(x);\n                    const symbol = global.checker.getSymbolAtLocation(node);\n                    let isClassDeclaration = false;\n                    if (symbol) {\n                        const first = symbol.declarations[0];\n                        if (first.kind === ts.SyntaxKind.ClassDeclaration) {\n                            isClassDeclaration = true;\n                        }\n                        if (first.kind === ts.SyntaxKind.ImportSpecifier) {\n                            const importedSymbol = global.checker.getAliasedSymbol(symbol);\n                            if (importedSymbol?.declarations[0]?.kind === ts.SyntaxKind.ClassDeclaration) {\n                                isClassDeclaration = true;\n                            }\n                        }\n                    }\n                    // console.log(node.getText(), 'isClass declaration', isClass);\n                    if (isClassDeclaration) {\n                        return `typeof(${idValue})`;\n                        // this does not work then the class is imported from another file because\n                        // the type is not resolved correctly and the symbol declaration is simply a importSpecifier\n                        // we would need to find a way to get the type from the importSpecifier\n                        // by loading the entire code upon transpiling the ts file\n                    }\n                }\n            }\n        }\n\n        return this.transformIdentifier(node, idValue); // check this later\n    }\n\n    printConstructorDeclaration (node, identation) {\n        const classNode = node.parent;\n        const className = this.printNode(classNode.name, 0);\n        const args = this.printMethodParameters(node);\n        const constructorBody = this.printFunctionBody(node, identation);\n\n        // find super call inside constructor and extract params\n        let superCallParams = '';\n        let hasSuperCall = false;\n        node.body?.statements.forEach(statement => {\n            if (ts.isExpressionStatement(statement)) {\n                const expression = statement.expression;\n                if (ts.isCallExpression(expression)) {\n                    const expressionText = expression.expression.getText().trim();\n                    if (expressionText === 'super') {\n                        hasSuperCall = true;\n                        superCallParams = expression.arguments.map((a) => {\n                            return this.printNode(a, identation).trim();\n                        }).join(\", \");\n                    }\n                }\n            }\n        });\n\n        if (hasSuperCall) {\n            return this.getIden(identation) + className +\n                `(${args}) : ${this.SUPER_CALL_TOKEN}(${superCallParams})` +\n                constructorBody;\n        }\n\n        return this.getIden(identation) +\n                className +\n                \"(\" + args + \")\" +\n                constructorBody;\n    }\n\n    printThisElementAccesssIfNeeded(node, identation) {\n        // convert this[method] into this.call(method) or this.callAsync(method)\n        // const isAsync = node?.parent?.kind === ts.SyntaxKind.AwaitExpression;\n        const isAsync = true; // setting to true for now, because there are some scenarios where we don't know\n        // if the call is async or not, so we need to assume it is async\n        // example Promise.all([this.unknownPropAsync()])\n        const elementAccess = node.expression;\n        if (elementAccess?.kind === ts.SyntaxKind.ElementAccessExpression) {\n            if (elementAccess?.expression?.kind === ts.SyntaxKind.ThisKeyword) {\n                let parsedArg = node.arguments?.length > 0 ? this.printNode(node.arguments[0], identation).trimStart() : \"\";\n                const propName = this.printNode(elementAccess.argumentExpression, 0);\n                const wrapperOpen = isAsync ? this.UKNOWN_PROP_ASYNC_WRAPPER_OPEN : this.UKNOWN_PROP_WRAPPER_OPEN;\n                const wrapperClose = isAsync ? this.UNKOWN_PROP_ASYNC_WRAPPER_CLOSE : this.UNKOWN_PROP_WRAPPER_CLOSE;\n                parsedArg = parsedArg ? \", \" + parsedArg : \"\";\n                return wrapperOpen + propName + parsedArg + wrapperClose;\n            }\n        }\n        return;\n    }\n\n    printDynamicCall(node, identation) {\n        const isAsync = true; // setting to true for now, because there are some scenarios where we don't know\n        const elementAccess = node.expression;\n        if (elementAccess?.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const parsedArg = node.arguments?.length > 0 ? node.arguments.map(n => this.printNode(n, identation).trimStart()).join(\", \") : \"\";\n            const target = this.printNode(elementAccess.expression, 0);\n            const propName = this.printNode(elementAccess.argumentExpression, 0);\n            const argsArray = `new object[] { ${parsedArg} }`;\n            const open = this.DYNAMIC_CALL_OPEN;\n            let statement = `${open}${target}, ${propName}, ${argsArray})`;\n            statement = isAsync ? `((Task<object>)${statement})` : statement;\n            return statement;\n        }\n        return undefined;\n    }\n\n\n    printElementAccessExpressionExceptionIfAny(node) {\n        // convert this[method] into this.call(method) or this.callAsync(method)\n    //    if (node?.expression?.kind === ts.SyntaxKind.ThisKeyword) {\n    //         const isAsyncDecl = node?.parent?.kind === ts.SyntaxKind.AwaitExpression;\n    //         const open = isAsyncDecl ? this.UKNOWN_PROP_ASYNC_WRAPPER_OPEN : this.UKNOWN_PROP_WRAPPER_OPEN;\n    //         return open.replace('(', '');\n    //    }\n    }\n\n    printWrappedUnknownThisProperty(node) {\n        const type = global.checker.getResolvedSignature(node);\n        if (type?.declaration === undefined) {\n            let parsedArguments = node.arguments?.map((a) => this.printNode(a, 0)).join(\", \");\n            parsedArguments = parsedArguments ? parsedArguments : \"\";\n            const propName = node.expression?.name.escapedText;\n            // const isAsyncDecl = true;\n            const isAsyncDecl = node?.parent?.kind === ts.SyntaxKind.AwaitExpression;\n            // const open = isAsyncDecl ? this.UKNOWN_PROP_ASYNC_WRAPPER_OPEN : this.UKNOWN_PROP_WRAPPER_OPEN;\n            // const close = this.UNKOWN_PROP_WRAPPER_CLOSE;\n            // return `${open}\"${propName}\"${parsedArguments}${close}`;\n            const argsArray = `new object[] { ${parsedArguments} }`;\n            const open = this.DYNAMIC_CALL_OPEN;\n            let statement = `${open}this, \"${propName}\", ${argsArray})`;\n            statement = isAsyncDecl ? `((Task<object>)${statement})` : statement;\n            return statement;\n        }\n        return undefined;\n    }\n\n    printOutOfOrderCallExpressionIfAny(node, identation) {\n        if (node.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const expressionText = node.expression.getText().trim();\n            const args = node.arguments;\n            if (args.length === 1) {\n                const parsedArg = this.printNode(args[0], 0);\n                switch (expressionText) {\n                // case \"JSON.parse\":\n                //     return `json_decode(${parsedArg}, $as_associative_array = true)`;\n                case \"Math.abs\":\n                    return `Math.Abs(Convert.ToDouble(${parsedArg}))`;\n                }\n            } else if (args.length === 2)\n            {\n                const parsedArg1 = this.printNode(args[0], 0);\n                const parsedArg2 = this.printNode(args[1], 0);\n                switch (expressionText) {\n                case \"Math.min\":\n                    return `mathMin(${parsedArg1}, ${parsedArg2})`;\n                case \"Math.max\":\n                    return `mathMax(${parsedArg1}, ${parsedArg2})`;\n                case \"Math.pow\":\n                    return `Math.Pow(Convert.ToDouble(${parsedArg1}), Convert.ToDouble(${parsedArg2}))`;\n                }\n            }\n            const leftSide = node.expression?.expression;\n            const leftSideText = leftSide ? this.printNode(leftSide, 0) : undefined;\n\n            // wrap unknown property this.X calls\n            if (leftSideText === this.THIS_TOKEN || leftSide.getFullText().indexOf(\"(this as any)\") > -1) { // double check this\n                const res = this.printWrappedUnknownThisProperty(node);\n                if (res) {\n                    return res;\n                }\n            }\n        }\n\n        // // replace this[method]() calls\n        // const thisElementAccess = this.printThisElementAccesssIfNeeded(node, identation);\n        // if (thisElementAccess) {\n        //     return thisElementAccess;\n        // }\n\n        // handle dynamic calls, this[method](A) or exchange[b] (c) using reflection\n        if (node.expression.kind === ts.SyntaxKind.ElementAccessExpression) {\n            return this.printDynamicCall(node, identation);\n        }\n\n\n        return undefined;\n    }\n\n    handleTypeOfInsideBinaryExpression(node, identation) {\n        const left = node.left;\n        const right = node.right.text;\n        const op = node.operatorToken.kind;\n        const expression = left.expression;\n\n        const isDifferentOperator = op === ts.SyntaxKind.ExclamationEqualsEqualsToken || op === ts.SyntaxKind.ExclamationEqualsToken;\n        const notOperator = isDifferentOperator ? this.NOT_TOKEN : \"\";\n\n        const target = this.printNode(expression, 0);\n        switch (right) {\n        case \"string\":\n            return notOperator + `(${target} is string)`;\n        case \"number\":\n            return notOperator + `(${target} is Int64 || ${target} is int || ${target} is float || ${target} is double)`;\n        case \"boolean\":\n            return notOperator + `(${target} is bool)`;\n        case \"object\":\n            return notOperator + `(${target} is IDictionary<string, object>)`;\n        case \"function\":\n            return notOperator + `(${target} is Delegate)`;\n        }\n\n        return undefined;\n\n    }\n\n    printCustomBinaryExpressionIfAny(node, identation) {\n        const left = node.left;\n        const right = node.right;\n\n        const op = node.operatorToken.kind;\n\n        if (left.kind === ts.SyntaxKind.TypeOfExpression) {\n            const typeOfExpression = this.handleTypeOfInsideBinaryExpression(node, identation);\n            if (typeOfExpression) {\n                return typeOfExpression;\n            }\n        }\n\n        // handle: [x,d] = this.method()\n        if (op === ts.SyntaxKind.EqualsToken && left.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayBindingPatternElements = left.elements;\n            const parsedArrayBindingElements = arrayBindingPatternElements.map((e) => this.printNode(e, 0));\n            const syntheticName = parsedArrayBindingElements.join(\"\") + \"Variable\";\n\n            let arrayBindingStatement = `var ${syntheticName} = ${this.printNode(right, 0)};\\n`;\n\n            parsedArrayBindingElements.forEach((e, index) => {\n                // const type = this.getType(node);\n                // const parsedType = this.getTypeFromRawType(type);\n                const leftElement = arrayBindingPatternElements[index];\n                const leftType = global.checker.getTypeAtLocation(leftElement);\n                const parsedType = this.getTypeFromRawType(leftType);\n\n                const castExp = parsedType ? `(${parsedType})` : \"\";\n\n                // const statement = this.getIden(identation) + `${e} = (${castExp}((List<object>)${syntheticName}))[${index}]`;\n                const statement = this.getIden(identation) + `${e} = ((IList<object>)${syntheticName})[${index}]`;\n                if (index < parsedArrayBindingElements.length - 1) {\n                    arrayBindingStatement += statement + \";\\n\";\n                } else {\n                    // printStatement adds the last ;\n                    arrayBindingStatement += statement;\n                }\n            });\n\n            return arrayBindingStatement;\n        }\n\n        if (op === ts.SyntaxKind.InKeyword) {\n            return `inOp(${this.printNode(right, 0)}, ${this.printNode(left, 0)})`;\n        }\n\n        const leftText = this.printNode(left, 0);\n        const rightText = this.printNode(right, 0);\n\n        if (op === ts.SyntaxKind.PlusEqualsToken) {\n            return `${leftText} = add(${leftText}, ${rightText})`;\n        }\n\n        if (op === ts.SyntaxKind.MinusEqualsToken) {\n            return `${leftText} = subtract(${leftText}, ${rightText})`;\n        }\n\n\n        if (op in this.binaryExpressionsWrappers) {\n            const wrapper = this.binaryExpressionsWrappers[op];\n            const open = wrapper[0];\n            const close = wrapper[1];\n            return `${open}${leftText}, ${rightText}${close}`;\n        }\n\n        // x = y\n        // cast y to x type when y is unknown\n        // if (op === ts.SyntaxKind.EqualsToken) {\n        //     const leftType = global.checker.getTypeAtLocation(left);\n        //     const rightType = global.checker.getTypeAtLocation(right);\n\n        //     if (this.isAnyType(rightType.flags) && !this.isAnyType(leftType.flags)) {\n        //         // const parsedType = this.getTypeFromRawType(leftType);\n        //         return `${leftText} = ${rightText}`;\n        //     }\n        // }\n\n        return undefined;\n    }\n\n    // castVariableAssignmentIfNeeded(left, right, identation) {\n    //     const leftType = global.checker.getTypeAtLocation(left);\n    //     const rightType = global.checker.getTypeAtLocation(right);\n\n    //     const leftText = this.printNode(left, 0);\n    //     const rightText = this.printNode(right, 0);\n\n    //     if (this.isAnyType(rightType.flags) && !this.isAnyType(leftType.flags)) {\n    //         const parsedType = this.getTypeFromRawType(leftType);\n    //         return `${this.getIden(identation)}${leftText} = (${parsedType})${rightText}`;\n    //     }\n    //     return undefined;\n    // }\n\n    printVariableDeclarationList(node,identation) {\n        const declaration = node.declarations[0];\n        // const name = declaration.name.escapedText;\n\n        if (this.removeVariableDeclarationForFunctionExpression && declaration?.initializer &&  ts.isFunctionExpression(declaration.initializer)) {\n            return this.printNode(declaration.initializer, identation).trimEnd();\n        }\n        // handle array binding : input: const [a,b] = this.method()\n        // output: var abVar = this.method; var a = abVar[0]; var b = abVar[1];\n        if (declaration?.name.kind === ts.SyntaxKind.ArrayBindingPattern) {\n            const arrayBindingPattern = declaration.name;\n            const arrayBindingPatternElements = arrayBindingPattern.elements;\n            const parsedArrayBindingElements = arrayBindingPatternElements.map((e) => this.printNode(e.name, 0));\n            const syntheticName = parsedArrayBindingElements.join(\"\") + \"Variable\";\n\n            let arrayBindingStatement =  `${this.getIden(identation)}var ${syntheticName} = ${this.printNode(declaration.initializer, 0)};\\n`;\n\n            parsedArrayBindingElements.forEach((e, index) => {\n                // const type = this.getType(node);\n                // const parsedType = this.getTypeFromRawType(type);\n                const statement = this.getIden(identation) + `var ${e} = ((IList<object>) ${syntheticName})[${index}]`;\n                if (index < parsedArrayBindingElements.length - 1) {\n                    arrayBindingStatement += statement + \";\\n\";\n                } else {\n                    // printStatement adds the last ;\n                    arrayBindingStatement += statement;\n                }\n            });\n\n            return arrayBindingStatement;\n        }\n\n        const isNew = declaration?.initializer && (declaration.initializer.kind === ts.SyntaxKind.NewExpression);\n        const varToken = isNew ? 'var ' : this.VAR_TOKEN + ' ' ;\n\n        // handle default undefined initialization\n        if (declaration?.initializer && declaration.initializer === undefined) {\n            // handle the let id: Str; case\n            return this.getIden(identation) + varToken + this.printNode(declaration.name) + \" = \" + this.UNDEFINED_TOKEN;\n        } else if (!declaration.initializer) {\n            return this.getIden(identation) + 'object ' + this.printNode(declaration.name) + \" = \" + this.UNDEFINED_TOKEN;\n        }\n        const parsedValue = this.printNode(declaration.initializer, identation).trimStart();\n        if (parsedValue === this.UNDEFINED_TOKEN) {\n            let specificVarToken = \"object\";\n            if (this.INFER_VAR_TYPE) {\n                const variableType = global.checker.typeToString(global.checker.getTypeAtLocation(declaration));\n                if (this.VariableTypeReplacements[variableType]) {\n                    specificVarToken = this.VariableTypeReplacements[variableType] + '?';\n                }\n            }\n            return this.getIden(identation) + specificVarToken + \" \" + this.printNode(declaration.name) + \" = \" + parsedValue;\n        }\n        return this.getIden(identation) + varToken + this.printNode(declaration.name) + \" = \" + parsedValue;\n    }\n\n    transformPropertyAcessExpressionIfNeeded(node) {\n        const expression = node.expression;\n        const leftSide = this.printNode(expression, 0);\n        const rightSide = node.name.escapedText;\n\n        let rawExpression = undefined;\n\n        switch(rightSide) {\n        case 'length':\n                const type = (global.checker as TypeChecker).getTypeAtLocation(expression); // eslint-disable-line\n            this.warnIfAnyType(node, type.flags, leftSide, \"length\");\n            // rawExpression = this.isStringType(type.flags) ? `(string${leftSide}).Length` : `(${leftSide}.Cast<object>().ToList()).Count`;\n            rawExpression = this.isStringType(type.flags) ? `((string)${leftSide}).Length` : `${this.ARRAY_LENGTH_WRAPPER_OPEN}${leftSide}${this.ARRAY_LENGTH_WRAPPER_CLOSE}`; // `(${leftSide}.Cast<object>()).ToList().Count`\n            break;\n        case 'push':\n            rawExpression = `((IList<object>)${leftSide}).Add`;\n            break;\n            // case 'push':\n            //     rawExpression = `(List<object>${leftSide}).Add`s\n            //     break;\n        }\n        return rawExpression;\n    }\n\n    printCustomDefaultValueIfNeeded(node) {\n        if (ts.isArrayLiteralExpression(node) || ts.isObjectLiteralExpression(node) || ts.isStringLiteral(node) || (ts as any).isBooleanLiteral(node)) {\n            return this.UNDEFINED_TOKEN;\n        }\n\n        if (ts.isNumericLiteral(node)) {\n            return this.UNDEFINED_TOKEN;\n        }\n\n        // convert x: number = undefined (invalid) into x = -1 (valid)\n        if (node?.escapedText === \"undefined\" && global.checker.getTypeAtLocation(node?.parent)?.flags === ts.TypeFlags.Number) {\n            // return \"-1\";\n            return this.UNDEFINED_TOKEN;\n        }\n\n        return undefined;\n    }\n\n    printFunctionBody(node, identation) {\n\n        // check if there is any default parameter to initialize\n        const funcParams = node.parameters;\n        const initParams = [];\n        if (funcParams.length > 0) {\n            const body = node.body.statements;\n            const first = body.length > 0 ? body[0] : [];\n            const remaining = body.length > 0 ? body.slice(1): [];\n            let firstStatement = this.printNode(first, identation + 1);\n\n            const remainingString = remaining.map((statement) => this.printNode(statement, identation + 1)).join(\"\\n\");\n            funcParams.forEach((param) => {\n                const initializer = param.initializer;\n                if (initializer) {\n                    if (ts.isArrayLiteralExpression(initializer)) {\n                        initParams.push(`${this.printNode(param.name, 0)} ??= new List<object>();`);\n                    }\n                    if (ts.isObjectLiteralExpression(initializer)) {\n                        initParams.push(`${this.printNode(param.name, 0)} ??= new Dictionary<string, object>();`);\n                    }\n                    if (ts.isNumericLiteral(initializer)) {\n                        initParams.push(`${this.printNode(param.name, 0)} ??= ${this.printNode(initializer, 0)};`);\n                    }\n                    if (ts.isStringLiteral(initializer)) {\n                        initParams.push(`${this.printNode(param.name, 0)} ??= ${this.printNode(initializer, 0)};`);\n                    }\n                    if ((ts as any).isBooleanLiteral(initializer)) {\n                        initParams.push(`${this.printNode(param.name, 0)} ??= ${this.printNode(initializer, 0)};`);\n                    }\n                }\n            });\n\n            if (initParams.length > 0) {\n                const defaultInitializers = initParams.map( l => this.getIden(identation+1) + l ).join(\"\\n\") + \"\\n\";\n                const bodyParts = firstStatement.split(\"\\n\");\n                const commentPart = bodyParts.filter(line => this.isComment(line));\n                const isComment = commentPart.length > 0;\n                if (isComment) {\n                    const commentPartString = commentPart.map((c) => this.getIden(identation+1) + c.trim()).join(\"\\n\");\n                    const firstStmNoComment = bodyParts.filter(line => !this.isComment(line)).join(\"\\n\");\n                    firstStatement = commentPartString + \"\\n\" + defaultInitializers + firstStmNoComment;\n                } else {\n                    firstStatement = defaultInitializers + firstStatement;\n                }\n            }\n            const blockOpen = this.getBlockOpen(identation);\n            const blockClose = this.getBlockClose(identation);\n            firstStatement = remainingString.length > 0 ? firstStatement + \"\\n\" : firstStatement;\n            return blockOpen + firstStatement + remainingString + blockClose;\n        }\n\n        return super.printFunctionBody(node, identation);\n    }\n\n    printInstanceOfExpression(node, identation) {\n        const left = node.left.escapedText;\n        const right = node.right.escapedText;\n        return this.getIden(identation) + `${left} is ${right}`;\n    }\n\n    printAsExpression(node, identation) {\n        const type = node.type;\n\n        if (type.kind === ts.SyntaxKind.AnyKeyword) {\n            return `((object)${this.printNode(node.expression, identation)})`;\n        }\n\n        if (type.kind === ts.SyntaxKind.StringKeyword) {\n            return `((string)${this.printNode(node.expression, identation)})`;\n        }\n\n        if (type.kind === ts.SyntaxKind.ArrayType) {\n            if (type.elementType.kind === ts.SyntaxKind.AnyKeyword) {\n                return `(IList<object>)(${this.printNode(node.expression, identation)})`;\n            }\n            if (type.elementType.kind === ts.SyntaxKind.StringKeyword) {\n                return `(IList<string>)(${this.printNode(node.expression, identation)})`;\n            }\n        }\n\n        return this.printNode(node.expression, identation);\n    }\n\n    printParameter(node, defaultValue = true) {\n        const name = this.printNode(node.name, 0);\n        const initializer = node.initializer;\n\n        let type = this.printParameterType(node);\n        type = type ? type : \"\";\n\n        if (defaultValue) {\n            if (initializer) {\n                const customDefaultValue = this.printCustomDefaultValueIfNeeded(initializer);\n                const defaultValue = customDefaultValue ? customDefaultValue : this.printNode(initializer, 0);\n                type = (defaultValue === \"null\" && type !== \"object\") ? type + \"? \": type + \" \";\n                return type + name + this.SPACE_DEFAULT_PARAM + \"=\" + this.SPACE_DEFAULT_PARAM + defaultValue;\n            }\n            return type + \" \" + name;\n        }\n        return name;\n    }\n\n    printArrayLiteralExpression(node) {\n\n        let arrayOpen = this.ARRAY_OPENING_TOKEN;\n        const elems = node.elements;\n\n        const elements = node.elements.map((e) => {\n            return this.printNode(e);\n        }).join(\", \");\n\n        // take into consideration list of promises\n        if (elems.length > 0) {\n            const first = elems[0];\n            if (first.kind === ts.SyntaxKind.CallExpression) {\n                // const type = global.checker.getTypeAtLocation(first);\n                let type = this.getFunctionType(first);\n                // const parsedType = this.getTypeFromRawType(type);\n                // parsedType === \"Task\" ||\n                // to do check this later\n                if (type === undefined || elements.indexOf(this.UKNOWN_PROP_ASYNC_WRAPPER_OPEN) > -1) {\n                    // if (type === undefined) {\n                    arrayOpen = \"new List<object> {\";\n                    // }\n                    //  else {\n                    //     arrayOpen = \"new List<Task<object>> {\";\n                    // }\n                } else {\n                    type = 'object';\n                    // check this out later\n                    // if (type === 'Task<List<object>>') {\n                    //     type = 'Task<object>';\n                    // }\n                    // if (type === 'string'){\n                    //     type = 'object';\n                    // }\n                    // type =\n                    arrayOpen = `new List<${type}> {`;\n                }\n            }\n        }\n\n        return arrayOpen + elements + this.ARRAY_CLOSING_TOKEN;\n    }\n\n    printMethodDefinition(node, identation) {\n        let name = node.name.escapedText;\n        name = this.transformMethodNameIfNeeded(name);\n\n        let returnType = this.printFunctionType(node);\n\n        let modifiers = this.printModifiers(node);\n        const defaultAccess = this.METHOD_DEFAULT_ACCESS ? this.METHOD_DEFAULT_ACCESS + \" \": \"\";\n        modifiers = modifiers ? modifiers + \" \" : defaultAccess; // tmp check this\n\n        modifiers = modifiers.indexOf(\"public\") === -1 && modifiers.indexOf(\"private\") === -1 && modifiers.indexOf(\"protected\") === -1 ? defaultAccess + modifiers : modifiers;\n\n        let parsedArgs = undefined;\n        // c# only move this elsewhere (csharp transpiler)\n        const methodOverride = this.getMethodOverride(node) as any;\n        const isOverride = methodOverride !== undefined;\n        modifiers = isOverride ? modifiers + \"override \" : modifiers + \"virtual \";\n\n        // infer parent return type\n        if (isOverride && (returnType === \"object\" || returnType === \"Task<object>\")) {\n            returnType = this.printFunctionType(methodOverride);\n        }\n\n        // ts does not infer parameters types of overriden methods :x , so we need some\n        // heuristic here to infer the types\n        if (isOverride && node.parameters.length > 0) {\n            const first = node.parameters[0];\n            const firstType = this.getType(first);\n\n            if (firstType === undefined) {\n                // use the override version, check this out later\n                // parsedArgs = this.printMethodParameters(methodOverride);\n                const currentArgs = node.parameters;\n                const parentArgs = methodOverride.parameters;\n                parsedArgs = \"\";\n                parentArgs.forEach((param, index) => {\n                    const originalName = this.printNode(currentArgs[index].name, 0);\n                    const parsedArg = this.printParameteCustomName(param, originalName);\n                    parsedArgs+= parsedArg;\n                    if (index < parentArgs.length - 1) {\n                        parsedArgs+= \", \";\n                    }\n                });\n            }\n        }\n\n        parsedArgs = parsedArgs ? parsedArgs : this.printMethodParameters(node);\n\n        returnType = returnType ? returnType + \" \" : returnType;\n\n        const methodToken = this.METHOD_TOKEN ? this.METHOD_TOKEN + \" \" : \"\";\n        const methodDef = this.getIden(identation) + modifiers + returnType + methodToken + name\n            + \"(\" + parsedArgs + \")\";\n\n        return this.printNodeCommentsIfAny(node, identation, methodDef);\n    }\n\n    printArgsForCallExpression(node, identation) {\n        const args = node.arguments;\n        let parsedArgs  = \"\";\n        if (false && this.requiresCallExpressionCast && !this.isBuiltInFunctionCall(node?.expression)) { //eslint-disable-line\n            const parsedTypes = this.getTypesFromCallExpressionParameters(node);\n            const tmpArgs = [];\n            args.forEach((arg, index) => {\n                const parsedType = parsedTypes[index];\n                let cast = \"\";\n                if (parsedType !== \"object\" && parsedType !== \"float\" && parsedType !== \"int\") {\n                    cast = parsedType ? `(${parsedType})` : '';\n                }\n                tmpArgs.push(cast + this.printNode(arg, identation).trim());\n            });\n            parsedArgs = tmpArgs.join(\",\");\n            return parsedArgs;\n        }\n        return super.printArgsForCallExpression(node, identation);\n    }\n\n    // check this out later\n\n    printArrayIsArrayCall(node, identation, parsedArg = undefined) {\n        return `((${parsedArg} is IList<object>) || (${parsedArg}.GetType().IsGenericType && ${parsedArg}.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))`;\n    }\n\n    printObjectKeysCall(node, identation, parsedArg = undefined) {\n        return `new List<object>(((IDictionary<string,object>)${parsedArg}).Keys)`;\n    }\n\n    printObjectValuesCall(node, identation, parsedArg = undefined) {\n        return `new List<object>(((IDictionary<string,object>)${parsedArg}).Values)`;\n    }\n\n    printJsonParseCall(node, identation, parsedArg = undefined) {\n        return `parseJson(${parsedArg})`;\n    }\n\n    printJsonStringifyCall(node, identation, parsedArg = undefined) {\n        return `json(${parsedArg})`; // make this customizable\n    }\n\n    printPromiseAllCall(node, identation, parsedArg = undefined) {\n        return `promiseAll(${parsedArg})`;\n    }\n\n    printMathFloorCall(node, identation, parsedArg = undefined) {\n        return `(Math.Floor(Double.Parse((${parsedArg}).ToString())))`;\n    }\n\n    printMathRoundCall(node, identation, parsedArg = undefined) {\n        return `Math.Round(Convert.ToDouble(${parsedArg}))`;\n    }\n\n    printMathCeilCall(node, identation, parsedArg = undefined) {\n        return `Math.Ceiling(Convert.ToDouble(${parsedArg}))`;\n    }\n\n    printNumberIsIntegerCall(node: any, identation: any, parsedArg?: any) {\n        return `((${parsedArg} is int) || (${parsedArg} is long) || (${parsedArg} is Int32) || (${parsedArg} is Int64))`;\n    }\n\n    printArrayPushCall(node, identation, name = undefined, parsedArg = undefined) {\n        return  `((IList<object>)${name}).Add(${parsedArg})`;\n    }\n\n    printIncludesCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `${name}.Contains(${parsedArg})`;\n    }\n\n    printIndexOfCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `${this.INDEXOF_WRAPPER_OPEN}${name}, ${parsedArg}${this.INDEXOF_WRAPPER_CLOSE}`;\n    }\n\n    printSearchCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `((string)${name}).IndexOf(${parsedArg})`;\n    }\n\n    printStartsWithCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `((string)${name}).StartsWith(((string)${parsedArg}))`;\n    }\n\n    printEndsWithCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `((string)${name}).EndsWith(((string)${parsedArg}))`;\n    }\n\n    printTrimCall(node, identation, name = undefined) {\n        return `((string)${name}).Trim()`;\n    }\n\n    printJoinCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `String.Join(${parsedArg}, ((IList<object>)${name}).ToArray())`;\n    }\n\n    printSplitCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `((string)${name}).Split(new [] {((string)${parsedArg})}, StringSplitOptions.None).ToList<object>()`;\n    }\n\n    printConcatCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `concat(${name}, ${parsedArg})`;\n    }\n\n    printToFixedCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `toFixed(${name}, ${parsedArg})`;\n    }\n\n    printToStringCall(node, identation, name = undefined) {\n        return `((object)${name}).ToString()`;\n    }\n\n    printToUpperCaseCall(node, identation, name = undefined) {\n        return `((string)${name}).ToUpper()`;\n    }\n\n    printToLowerCaseCall(node, identation, name = undefined) {\n        return `((string)${name}).ToLower()`;\n    }\n\n    printShiftCall(node, identation, name = undefined) {\n        return `((IList<object>)${name}).First()`;\n    }\n\n    printReverseCall(node, identation, name = undefined) {\n        return `${name} = (${name} as IList<object>).Reverse().ToList()`;\n    }\n\n    printPopCall(node, identation, name = undefined) {\n        return `((IList<object>)${name}).Last()`;\n    }\n\n    printAssertCall(node, identation, parsedArgs) {\n        return `assert(${parsedArgs})`;\n    }\n\n    printSliceCall(node, identation, name = undefined, parsedArg = undefined, parsedArg2 = undefined) {\n        if (parsedArg2 === undefined){\n            // return `((string)${name}).Substring((int)${parsedArg})`;\n            parsedArg2 = 'null';\n        }\n        // return `((string)${name})[((int)${parsedArg})..((int)${parsedArg2})]`;\n        return `slice(${name}, ${parsedArg}, ${parsedArg2})`;\n    }\n\n    printReplaceCall(node, identation, name = undefined, parsedArg = undefined, parsedArg2 = undefined) {\n        return `((string)${name}).Replace((string)${parsedArg}, (string)${parsedArg2})`;\n    }\n\n    printReplaceAllCall(node, identation, name = undefined, parsedArg = undefined, parsedArg2 = undefined) {\n        return `((string)${name}).Replace((string)${parsedArg}, (string)${parsedArg2})`;\n    }\n\n    printPadEndCall(node, identation, name, parsedArg, parsedArg2) {\n        return `(${name} as String).PadRight(Convert.ToInt32(${parsedArg}), Convert.ToChar(${parsedArg2}))`;\n    }\n\n    printPadStartCall(node, identation, name, parsedArg, parsedArg2) {\n        return `(${name} as String).PadLeft(Convert.ToInt32(${parsedArg}), Convert.ToChar(${parsedArg2}))`;\n    }\n\n    printDateNowCall(node, identation) {\n        return \"(new DateTimeOffset(DateTime.UtcNow)).ToUnixTimeMilliseconds()\";\n    }\n\n    printLengthProperty(node, identation, name = undefined) {\n        const leftSide = this.printNode(node.expression, 0);\n        const type = (global.checker as TypeChecker).getTypeAtLocation(node.expression); // eslint-disable-line\n        this.warnIfAnyType(node, type.flags, leftSide, \"length\");\n        return this.isStringType(type.flags) ? `((string)${leftSide}).Length` : `${this.ARRAY_LENGTH_WRAPPER_OPEN}${leftSide}${this.ARRAY_LENGTH_WRAPPER_CLOSE}`;\n    }\n\n    printPostFixUnaryExpression(node, identation) {\n        const {operand, operator} = node;\n        if (operand.kind === ts.SyntaxKind.NumericLiteral) {\n            return super.printPostFixUnaryExpression(node, identation);\n        }\n        const leftSide = this.printNode(operand, 0);\n        const op = this.PostFixOperators[operator]; // todo: handle --\n        if (op === '--') {\n            return `postFixDecrement(ref ${leftSide})`;\n        }\n        return `postFixIncrement(ref ${leftSide})`;\n    }\n\n    printPrefixUnaryExpression(node, identation) {\n        const {operand, operator} = node;\n        if (operand.kind === ts.SyntaxKind.NumericLiteral) {\n            return super.printPrefixUnaryExpression(node, identation);\n        }\n        if (operator === ts.SyntaxKind.ExclamationToken) {\n            // not branch check falsy/turthy values if needed;\n            return  this.PrefixFixOperators[operator] + this.printCondition(node.operand, 0);\n        }\n        const leftSide = this.printNode(operand, 0);\n        if (operator === ts.SyntaxKind.PlusToken) {\n            return `prefixUnaryPlus(ref ${leftSide})`;\n        } else {\n            return `prefixUnaryNeg(ref ${leftSide})`;\n        }\n    }\n\n    printConditionalExpression(node, identation) {\n        const condition = this.printCondition(node.condition, 0);\n        const whenTrue = this.printNode(node.whenTrue, 0);\n        const whenFalse = this.printNode(node.whenFalse, 0);\n\n        return `((bool) ${condition})` + \" ? \" + whenTrue + \" : \" + whenFalse;\n    }\n\n    printDeleteExpression(node, identation) {\n        const object = this.printNode (node.expression.expression, 0);\n        const key = this.printNode (node.expression.argumentExpression, 0);\n        return `((IDictionary<string,object>)${object}).Remove((string)${key})`;\n    }\n\n    printThrowStatement(node, identation) {\n        // const expression = this.printNode(node.expression, 0);\n        // return this.getIden(node) + this.THROW_TOKEN + \" \" + expression + this.LINE_TERMINATOR;\n        if (node.expression.kind === ts.SyntaxKind.Identifier) {\n            return this.getIden(identation) + this.THROW_TOKEN + ' ' + this.printNode(node.expression, 0) + this.LINE_TERMINATOR;\n        }\n        if (node.expression.kind === ts.SyntaxKind.NewExpression) {\n            const expression = node.expression;\n            // handle throw new Error (Message)\n            // and throw new x[a] (message)\n            const argumentsExp = expression?.arguments ?? [];\n            const parsedArg = argumentsExp.map(n => this.printNode(n, 0)).join(\",\") ?? '';\n            const newExpression =  this.printNode(expression.expression, 0);\n            if (expression.expression.kind === ts.SyntaxKind.Identifier) {\n                // handle throw new X\n                const id = expression.expression;\n                const symbol = global.checker.getSymbolAtLocation(expression.expression);\n                if (symbol) {\n                    const declarations = global.checker.getDeclaredTypeOfSymbol(symbol).symbol?.declarations ?? [];\n                    const isClassDeclaration = declarations.find(l => l.kind === ts.SyntaxKind.InterfaceDeclaration ||  l.kind === ts.SyntaxKind.ClassDeclaration);\n                    if (isClassDeclaration){\n                        return this.getIden(identation) + `${this.THROW_TOKEN} ${this.NEW_TOKEN} ${id.escapedText} ((string)${parsedArg}) ${this.LINE_TERMINATOR}`;\n                    } else {\n                        return this.getIden(identation) + `throwDynamicException(${id.escapedText}, ${parsedArg});return null;`;\n                    }\n                }\n                return this.getIden(identation) + `${this.THROW_TOKEN} ${this.NEW_TOKEN} ${newExpression} (${parsedArg}) ${this.LINE_TERMINATOR}`;\n            } else if (expression.expression.kind === ts.SyntaxKind.ElementAccessExpression) {\n                return this.getIden(identation) + `throwDynamicException(${newExpression}, ${parsedArg});`;\n            }\n            return super.printThrowStatement(node, identation);\n        }\n        // const newToken = this.NEW_TOKEN ? this.NEW_TOKEN + \" \" : \"\";\n        // const newExpression = node.expression?.expression?.escapedText;\n        // // newExpression = newExpression ? newExpression : this.printNode(node.expression.expression, 0); // new Exception or new exact[string] check this out\n        // // const args = node.expression?.arguments.map(n => this.printNode(n, 0)).join(\",\");\n        // // const throwExpression = ` ${newToken}${newExpression}${this.LEFT_PARENTHESIS}((string)${args})${this.RIGHT_PARENTHESIS}`;\n        // return this.getIden(identation) + this.THROW_TOKEN + throwExpression + this.LINE_TERMINATOR;\n    }\n\n    csModifiers = {\n\n    };\n\n    printPropertyAccessModifiers(node) {\n        let modifiers = this.printModifiers(node);\n        if (modifiers === '') {\n            modifiers = this.defaultPropertyAccess;\n        }\n        // add type\n        let typeText = 'object';\n        if (node.type) {\n            typeText = this.getType(node);\n            if (!typeText) {\n                if (node.type.kind === ts.SyntaxKind.AnyKeyword) {\n                    typeText = this.OBJECT_KEYWORD + ' ';\n                }\n            }\n        }\n        return modifiers + ' ' + typeText + ' ';\n    }\n\n    // printLeadingComments(node, identation) {\n    //     const fullText = global.src.getFullText();\n    //     const commentsRangeList = ts.getLeadingCommentRanges(fullText, node.pos);\n    //     const commentsRange = commentsRangeList ? commentsRangeList : undefined;\n    //     let res = \"\";\n    //     if (commentsRange) {\n    //         for (const commentRange of commentsRange) {\n    //             const commentText = fullText.slice(commentRange.pos, commentRange.end);\n    //             if (commentText !== undefined) {\n    //                 const formatted = commentText\n    //                     .split(\"\\n\")\n    //                     .map(line=>line.trim())\n    //                     .map(line => !(line.trim().startsWith(\"*\")) ? this.getIden(identation) + line : this.getIden(identation) + \" \" + line) .join(\"\\n\");\n    //                 // res+= this.transformLeadingComment(formatted) + \"\\n\";\n    //             }\n    //         }\n    //     }\n    //     return res;\n    // }\n}\n\n// if (this.requiresCallExpressionCast) {\n//     const parsedTypes = this.getTypesFromCallExpressionParameters(node);\n//     const tmpArgs = [];\n//     args.forEach((arg, index) => {\n//         const parsedType = parsedTypes[index];\n//         const cast = parsedType ? `(${parsedType})` : '';\n//         tmpArgs.push(cast + this.printNode(arg, identation).trim());\n//     });\n//     parsedArgs = tmpArgs.join(\",\");\n// } else {\n//     parsedArgs = args.map((a) => {\n//         return  this.printNode(a, identation).trim();\n//     }).join(\", \");\n// }\n\n// getTypesFromCallExpressionParameters(node) {\n//     const resolvedParams = global.checker.getResolvedSignature(node).parameters;\n//     const parsedTypes = [];\n//     resolvedParams.forEach((p) => {\n//         const decl = p.declarations[0];\n//         const type = global.checker.getTypeAtLocation(decl);\n//         const parsedType = this.getTypeFromRawType(type);\n//         parsedTypes.push(parsedType);\n//     });\n\n//     return parsedTypes;\n// }\n\n\n// get class decl node\n// Use the ts.getAllSuperTypeNodes function to get the base classes for the MyClass\n// const baseClasses = ts.getAllSuperTypeNodes(classDeclaration);\n\n// // Create a type checker\n// const typeChecker = ts.createTypeChecker(sourceFile.context.program, sourceFile.context.checker);\n\n// // Get the type of the base class\n// const baseClassType = typeChecker.getTypeAtLocation(baseClasses[0]);\n\n// // Get the class declaration for the base class\n// const baseClassDeclaration = baseClassType.symbol.valueDeclaration;\n\n// console.log(baseClassDeclaration);\n","import { BaseTranspiler } from \"./baseTranspiler.js\";\nimport ts, { BinaryExpression, CallExpression, TypeChecker } from 'typescript';\n\nconst SyntaxKind = ts.SyntaxKind;\n\nconst parserConfig = {\n    'ELSEIF_TOKEN': 'else if',\n    'OBJECT_OPENING': 'map[string]interface{} {',\n    'ARRAY_OPENING_TOKEN': '[]interface{}{',\n    'ARRAY_CLOSING_TOKEN': '}',\n    'PROPERTY_ASSIGNMENT_TOKEN': ':',\n    'VAR_TOKEN': 'object', // object\n    'METHOD_TOKEN': 'func',\n    'PROPERTY_ASSIGNMENT_OPEN': '',\n    'PROPERTY_ASSIGNMENT_CLOSE': '',\n    'SUPER_TOKEN': 'base',\n    'SUPER_CALL_TOKEN': 'base',\n    'FALSY_WRAPPER_OPEN': 'IsTrue(',\n    'FALSY_WRAPPER_CLOSE': ')',\n    'COMPARISON_WRAPPER_OPEN' : \"IsEqual(\",\n    'COMPARISON_WRAPPER_CLOSE' : \")\",\n    'UKNOWN_PROP_WRAPPER_OPEN': 'this.call(',\n    'UNKOWN_PROP_WRAPPER_CLOSE': ')',\n    'UKNOWN_PROP_ASYNC_WRAPPER_OPEN': 'this.callAsync(',\n    'UNKOWN_PROP_ASYNC_WRAPPER_CLOSE': ')',\n    'DYNAMIC_CALL_OPEN': 'callDynamically(',\n    'EQUALS_EQUALS_WRAPPER_OPEN': 'IsEqual(',\n    'EQUALS_EQUALS_WRAPPER_CLOSE': ')',\n    'DIFFERENT_WRAPPER_OPEN': '!IsEqual(',\n    'DIFFERENT_WRAPPER_CLOSE': ')',\n    'GREATER_THAN_WRAPPER_OPEN': 'IsGreaterThan(',\n    'GREATER_THAN_WRAPPER_CLOSE': ')',\n    'GREATER_THAN_EQUALS_WRAPPER_OPEN': 'IsGreaterThanOrEqual(',\n    'GREATER_THAN_EQUALS_WRAPPER_CLOSE': ')',\n    'LESS_THAN_WRAPPER_OPEN': 'IsLessThan(',\n    'LESS_THAN_WRAPPER_CLOSE': ')',\n    'LESS_THAN_EQUALS_WRAPPER_OPEN': 'IsLessThanOrEqual(',\n    'LESS_THAN_EQUALS_WRAPPER_CLOSE': ')',\n    'PLUS_WRAPPER_OPEN':'Add(',\n    'PLUS_WRAPPER_CLOSE':')',\n    'MINUS_WRAPPER_OPEN':'Subtract(',\n    'MINUS_WRAPPER_CLOSE':')',\n    'ARRAY_LENGTH_WRAPPER_OPEN': 'GetArrayLength(',\n    'ARRAY_LENGTH_WRAPPER_CLOSE': ')',\n    'DIVIDE_WRAPPER_OPEN': 'Divide(',\n    'DIVIDE_WRAPPER_CLOSE': ')',\n    'MULTIPLY_WRAPPER_OPEN': 'Multiply(',\n    'MULTIPLY_WRAPPER_CLOSE': ')',\n    'INDEXOF_WRAPPER_OPEN': 'GetIndexOf(',\n    'INDEXOF_WRAPPER_CLOSE': ')',\n    'MOD_WRAPPER_OPEN': 'Mod(',\n    'MOD_WRAPPER_CLOSE': ')',\n    'FUNCTION_TOKEN': 'func',\n    'DEFAULT_RETURN_TYPE': 'interface{}',\n    'BLOCK_OPENING_TOKEN': '{',\n    'DEFAULT_PARAMETER_TYPE': 'interface{}',\n    'LINE_TERMINATOR': '',\n    'CONDITION_OPENING':'',\n    'CONDITION_CLOSE':'',\n    'AWAIT_TOKEN': '',\n    'NULL_TOKEN': 'nil',\n    'UNDEFINED_TOKEN': 'nil',\n    'WHILE_TOKEN': 'for',\n    'ELEMENT_ACCESS_WRAPPER_OPEN': 'GetValue(',\n    'ELEMENT_ACCESS_WRAPPER_CLOSE': ')',\n};\n\nexport class GoTranspiler extends BaseTranspiler {\n\n    binaryExpressionsWrappers;\n    wrapThisCalls: boolean;\n    wrapCallMethods: string[] = [];\n    className: string;\n    classNameMap: { [key: string]: string };\n    DEFAULT_RETURN_TYPE = 'interface{}';\n\n    constructor(config = {}) {\n        config['parser'] = Object.assign ({}, parserConfig, config['parser'] ?? {});\n\n        super(config);\n\n        this.requiresParameterType = true;\n        this.requiresReturnType = true;\n        this.asyncTranspiling = false;\n        this.supportsFalsyOrTruthyValues = false;\n        this.requiresCallExpressionCast = true;\n        this.wrapThisCalls = false;\n        this.id = \"Go\";\n        this.className = \"undefined\";\n        this.classNameMap = config['classNameMap'] ?? {};\n        this.initConfig();\n\n        // user overrides\n        this.applyUserOverrides(config);\n        this.wrapThisCalls = config['wrapThisCalls'] ?? false;\n        this.wrapCallMethods = config['wrapCallMethods'] ?? [];\n    }\n\n    initConfig() {\n        this.LeftPropertyAccessReplacements = {\n            // 'this': '$this',\n        };\n\n        this.RightPropertyAccessReplacements = {\n            'push': 'Add', // list method\n            'indexOf': 'IndexOf', // list method\n            'toUpperCase': 'ToUpper',\n            'toLowerCase': 'ToLower',\n            'toString': 'ToString',\n        };\n\n        this.FullPropertyAccessReplacements = {\n            'JSON.parse': 'parseJson', // custom helper method\n            'console.log': 'fmt.Println',\n            'Number.MAX_SAFE_INTEGER': 'Int32.MaxValue',\n            'Math.min': 'Math.Min',\n            'Math.max': 'Math.Max',\n            'Math.log': 'Math.Log',\n            'Math.abs': 'Math.Abs',\n            // 'Math.ceil':  'Math.Ceiling', // need cast\n            // 'Math.round': 'Math.Round', // need to cast\n            'Math.floor': 'Math.Floor',\n            'Math.pow': 'Math.Pow',\n            // 'Promise.all': 'Task.WhenAll',\n        };\n\n        this.CallExpressionReplacements = {\n            // \"parseInt\": \"parseINt\",\n            // \"parseFloat\": \"float.Parse\",\n        };\n\n        this.ReservedKeywordsReplacements = {\n            // 'string': 'str',\n            // 'params': 'parameters',\n            'type': 'typeVar',\n            // 'internal': 'intern',\n            // 'event': 'eventVar',\n            // 'fixed': 'fixedVar',\n        };\n\n        this.binaryExpressionsWrappers = {\n            [ts.SyntaxKind.EqualsEqualsToken]: [this.EQUALS_EQUALS_WRAPPER_OPEN, this.EQUALS_EQUALS_WRAPPER_CLOSE],\n            [ts.SyntaxKind.EqualsEqualsEqualsToken]: [this.EQUALS_EQUALS_WRAPPER_OPEN, this.EQUALS_EQUALS_WRAPPER_CLOSE],\n            [ts.SyntaxKind.ExclamationEqualsToken]: [this.DIFFERENT_WRAPPER_OPEN, this.DIFFERENT_WRAPPER_CLOSE],\n            [ts.SyntaxKind.ExclamationEqualsEqualsToken]: [this.DIFFERENT_WRAPPER_OPEN, this.DIFFERENT_WRAPPER_CLOSE],\n            [ts.SyntaxKind.GreaterThanToken]: [this.GREATER_THAN_WRAPPER_OPEN, this.GREATER_THAN_WRAPPER_CLOSE],\n            [ts.SyntaxKind.GreaterThanEqualsToken]: [this.GREATER_THAN_EQUALS_WRAPPER_OPEN, this.GREATER_THAN_EQUALS_WRAPPER_CLOSE],\n            [ts.SyntaxKind.LessThanToken]: [this.LESS_THAN_WRAPPER_OPEN, this.LESS_THAN_WRAPPER_CLOSE],\n            [ts.SyntaxKind.LessThanEqualsToken]: [this.LESS_THAN_EQUALS_WRAPPER_OPEN, this.LESS_THAN_EQUALS_WRAPPER_CLOSE],\n            [ts.SyntaxKind.PlusToken]: [this.PLUS_WRAPPER_OPEN, this.PLUS_WRAPPER_CLOSE],\n            [ts.SyntaxKind.MinusToken]: [this.MINUS_WRAPPER_OPEN, this.MINUS_WRAPPER_CLOSE],\n            [ts.SyntaxKind.AsteriskToken]: [this.MULTIPLY_WRAPPER_OPEN, this.MULTIPLY_WRAPPER_CLOSE],\n            [ts.SyntaxKind.PercentToken]: [this.MOD_WRAPPER_OPEN, this.MOD_WRAPPER_CLOSE],\n            [ts.SyntaxKind.SlashToken]: [this.DIVIDE_WRAPPER_OPEN, this.DIVIDE_WRAPPER_CLOSE],\n        };\n    }\n\n    // getBlockOpen(identation){\n    //     return this.getIden(identation)  + this.BLOCK_OPENING_TOKEN;\n    // }\n\n    printSuperCallInsideConstructor(node, identation) {\n        return \"\"; // csharp does not need super call inside constructor\n    }\n\n    printStringLiteral(node) {\n        const token = this.STRING_QUOTE_TOKEN;\n        let text = node.text;\n        if (text in this.StringLiteralReplacements) {\n            return this.StringLiteralReplacements[text];\n        }\n        text = text.replaceAll(\"'\", \"\\\\\\\\\" + \"'\");\n        text = text.replaceAll(\"\\\"\", \"\\\\\" + \"\\\"\");\n        text = text.replaceAll(\"\\n\", \"\\\\n\");\n        return token + text + token;\n    }\n\n    transformFunctionNameIfNeeded(name): string {\n        return this.capitalize(name);\n    }\n\n\n    printPropertyDeclaration(node, identation) {\n        // let modifiers = this.printModifiers(node);\n        // modifiers = modifiers ? modifiers + \" \" : modifiers;\n        const name = this.capitalize(this.printNode(node.name, 0));\n        let type = 'interface{}';\n        if (node.type === undefined) {\n            type = 'interface{}';\n        } else if (node.type.kind === SyntaxKind.StringKeyword) {\n            type = 'string';\n        } else if (node.type.kind === SyntaxKind.NumberKeyword) {\n            type = 'int';\n        } else if (node.type.kind === SyntaxKind.BooleanKeyword || (ts as any).isBooleanLiteral(node)) {\n            type = 'bool';\n        } else if (node.type.kind === SyntaxKind.ArrayType) {\n            type = '[]interface{}';\n        }\n        if (node.initializer) {\n            // we have to save the value and initialize it later\n            let initializer = this.printNode(node.initializer, 0);\n            // quick fix\n            initializer = initializer.replaceAll('\"', '');\n            return this.getIden(identation) + name + ' ' + type + ' ' + `\\`default:\"${initializer}\"\\`` + this.LINE_TERMINATOR;\n        }\n        return this.getIden(identation) + name + ' ' + type + this.LINE_TERMINATOR;\n    }\n\n    printStruct(node, indentation) {\n\n        // check if we have heritage\n        let heritageName = '';\n        if (node?.heritageClauses?.length > 0) {\n            const heritage = node.heritageClauses[0];\n            const heritageType = heritage.types[0];\n            let heritageEscapedText = heritageType.expression.escapedText;\n            if (this.classNameMap[heritageEscapedText]) {\n                heritageEscapedText = this.classNameMap[heritageEscapedText];\n            }\n            heritageName = this.getIden(indentation+1) + heritageEscapedText + '\\n';\n        }\n\n        const propDeclarations = node.members.filter(member => member.kind === SyntaxKind.PropertyDeclaration);\n        return `type ${this.className} struct {\\n${heritageName}${propDeclarations.map(member => this.printNode(member, indentation+1)).join(\"\\n\")}\\n}`;\n    }\n\n    printNewStructMethod(node){\n        return `\nfunc New${this.capitalize(this.className)}() *${(this.className)} {\n    p := &${this.className}{}\n    setDefaults(p)\n    return p\n}\\n`;\n        // TO remove `return copies lock value: github.com/ccxt/ccxt/go/v4.bitvavoWs contains github.com/ccxt/ccxt/go/v4.bitvavo contains github.com/ccxt/ccxt/go/v4.Exchange contains sync.Mutex`\n        // change the return value to\n        //\n        //         return `\n        // func New${this.capitalize(className)}() *${(className)} {\n        //    p := ${className}{}\n        //    setDefaults(&p)\n        //    return &p\n        // }\\n`;\n        //\n\n    }\n\n    printClass(node, identation) {\n        this.className = node.name.escapedText;\n        if (this.classNameMap[this.className]) {\n            this.className = this.classNameMap[this.className];\n        }\n\n        const struct = this.printStruct(node, identation);\n        const newMethod = this.printNewStructMethod(node);\n\n        const methods = node.members.filter(member => member.kind === SyntaxKind.MethodDeclaration);\n        const classMethods = methods.map(method => this.printMethodDeclaration(method, identation)).join(\"\\n\");\n        // const classDefinition = this.printClassDefinition(node, identation);\n\n        // const classBody = this.printClassBody(node, identation);\n\n        // const classClosing = this.getBlockClose(identation);\n\n        // return classDefinition + classBody + classClosing;\n        return struct + \"\\n\" + newMethod  + \"\\n\" + classMethods;\n    }\n\n    printPropertyAccessModifiers (node) {\n        return \"\";\n    }\n\n    printSpreadElement(node, identation) {\n        const expression = this.printNode(node.expression, 0);\n        return this.getIden(identation) + expression + this.SPREAD_TOKEN;\n    }\n\n    printMethodDeclaration(node, identation) {\n\n        let methodDef = this.printMethodDefinition(node, identation);\n\n        const isAsync = this.isAsyncFunction(node);\n\n        const funcBody = this.printFunctionBody(node, identation, isAsync);\n\n        methodDef += funcBody;\n\n        return methodDef;\n    }\n\n    printFunctionDeclaration(node, identation) {\n        if (ts.isArrowFunction(node)) {\n            const parameters = node.parameters.map(param => this.printParameter(param)).join(\", \");\n            const body = this.printNode(node.body);\n            return `(${parameters}) => ${body}`;\n        }\n        const isAsync = this.isAsyncFunction(node);\n        let functionDef = this.printFunctionDefinition(node, identation);\n        const funcBody = this.printFunctionBody(node, identation, isAsync);\n        functionDef += funcBody;\n\n        return this.printNodeCommentsIfAny(node, identation, functionDef);\n    }\n\n    printMethodDefinition(node, identation) {\n        let name = node.name.escapedText;\n        name = this.transformMethodNameIfNeeded(name);\n\n        let returnType = this.printFunctionType(node);\n\n        const parsedArgs = this.printMethodParameters(node);\n\n        returnType = returnType ? returnType + \" \" : returnType;\n\n        const methodToken = this.METHOD_TOKEN ? this.METHOD_TOKEN + \" \" : \"\";\n        // const methodDef = this.getIden(identation) + returnType + methodToken + name\n        //     + \"(\" + parsedArgs + \")\";\n        const structReceiver = `(${this.THIS_TOKEN} *${this.className})`;\n        const methodDef = this.getIden(identation) + methodToken + \" \" + structReceiver + \" \" + name + \"(\" + parsedArgs + \") \" + returnType;\n\n        return this.printNodeCommentsIfAny(node, identation, methodDef);\n    }\n\n\n    printFunctionDefinition(node, identation) {\n        let name = node.name.escapedText;\n        name = this.transformMethodNameIfNeeded(name);\n\n        let returnType = this.printFunctionType(node);\n\n        const parsedArgs = this.printMethodParameters(node);\n\n        returnType = returnType ? returnType + \" \" : returnType;\n\n        const methodToken = this.METHOD_TOKEN ? this.METHOD_TOKEN + \" \" : \"\";\n        // const methodDef = this.getIden(identation) + returnType + methodToken + name\n        //     + \"(\" + parsedArgs + \")\";\n        const methodDef = this.getIden(identation) + methodToken + name + \"(\" + parsedArgs + \") \" + returnType;\n\n        return this.printNodeCommentsIfAny(node, identation, methodDef);\n    }\n\n    printMethodParameters(node) {\n        const params = node.parameters.map(param => this.printParameter(param));\n        const hasOptionalParameter = params.some(p => p === 'optional');\n        if (!hasOptionalParameter) {\n            return params.join(\", \");\n        }\n        const paramsWithOptional = params.filter(param => param !== 'optional');\n        paramsWithOptional.push('optionalArgs ...interface{}');\n        return paramsWithOptional.join(\", \");\n    }\n\n    printParameter(node, defaultValue = true) {\n        const name = this.printNode(node.name, 0);\n        const initializer = node.initializer;\n\n        const type = this.printParameterType(node);\n\n        if (defaultValue) {\n            if (initializer) {\n                return 'optional'; // will be handled later\n            }\n            // not supported we have to find an alternative for go like defining multiple methods with different parameters\n            // if (initializer) {\n            //     const customDefaultValue = this.printCustomDefaultValueIfNeeded(initializer);\n            //     const defaultValue = customDefaultValue ? customDefaultValue : this.printNode(initializer, 0);\n            //     return type + name + this.SPACE_DEFAULT_PARAM + \"=\" + this.SPACE_DEFAULT_PARAM + defaultValue;\n            // }\n            return name + ' ' + type;\n        }\n        return name + ' ' + type;\n    }\n\n    printParameterType(node) {\n        const typeText = this.getType(node);\n        // // if (typeText === this.BOOLEAN_KEYWORD) {\n        // //     return typeText;\n        // // }\n\n        //tmp default to interface\n        return 'interface{}';\n\n        if (typeText === this.STRING_KEYWORD) {\n            return 'string';\n        }\n        if (typeText === this.NUMBER_KEYWORD) {\n            return 'float64';\n        }\n\n        if (typeText === this.BOOLEAN_KEYWORD) {\n            return 'bool';\n        }\n\n        return this.DEFAULT_PARAMETER_TYPE;\n\n        if (typeText === undefined || typeText === this.STRING_KEYWORD) {\n            // throw new FunctionReturnTypeError(\"Parameter type is not supported or undefined\");\n            this.warn(node, node.getText(), \"Parameter type not found, will default to: \" + this.DEFAULT_PARAMETER_TYPE);\n            return this.DEFAULT_PARAMETER_TYPE;\n        }\n        return typeText;\n\n    }\n\n    printFunctionType(node){\n        const typeText = this.getFunctionType(node);\n        if (typeText === 'void') {\n            // // If the function is async (returns a Promise in TS) but declared void, emit a typed channel\n            // if (this.isAsyncFunction(node)) {\n            //     // Ensure element type is present; some edge cases yield '<- chan' only\n            //     const elementType = this.DEFAULT_RETURN_TYPE || 'interface{}';\n            //     return `<- chan ${elementType}`;\n            // }\n            return \"\";\n        }\n        if (typeText === undefined || (typeText !== this.VOID_KEYWORD && typeText !== this.PROMISE_TYPE_KEYWORD)) {\n            // throw new FunctionReturnTypeError(\"Function return type is not supported\");\n            let res = \"\";\n            if (this.isAsyncFunction(node)) {\n                res = `<- chan ${this.DEFAULT_RETURN_TYPE}`;\n            } else {\n                res = this.DEFAULT_RETURN_TYPE;\n            }\n            this.warn(node, node.name.getText(), \"Function return type not found, will default to: \" + res);\n            return res;\n        }\n        if (typeText === this.PROMISE_TYPE_KEYWORD) {\n            return `<- chan interface{}`;\n        }\n\n        // move any trailing array brackets \"[]\" to directly precede the element type\n        if (typeText && typeText.endsWith('[]')) {\n            const core = typeText.substring(0, typeText.length - 2); // drop []\n            const lastBracketPos = core.lastIndexOf(']');\n            if (lastBracketPos !== -1) {\n                // insert [] right after the last ']'\n                return core.substring(0, lastBracketPos + 1) + '[]' + core.substring(lastBracketPos + 1);\n            }\n        }\n        return typeText;\n    }\n\n    printVariableDeclarationList(node,identation) {\n        const declaration = node.declarations[0];\n        // const varToken = this.VAR_TOKEN ? this.VAR_TOKEN + \" \": \"\";\n        // const name = declaration.name.escapedText;\n\n        if (declaration?.name.kind === ts.SyntaxKind.ArrayBindingPattern) {\n            const arrayBindingPattern = declaration.name;\n            const arrayBindingPatternElements = arrayBindingPattern.elements;\n            const parsedArrayBindingElements = arrayBindingPatternElements.map((e) => this.printNode(e.name, 0));\n            const syntheticName = parsedArrayBindingElements.join(\"\") + \"Variable\";\n\n            let arrayBindingStatement =  `${this.getIden(identation)}${syntheticName} := ${this.printNode(declaration.initializer, 0)};\\n`;\n\n            parsedArrayBindingElements.forEach((e, index) => {\n                // const type = this.getType(node);\n                // const parsedType = this.getTypeFromRawType(type);\n                const statement = this.getIden(identation) + `${e} := GetValue(${syntheticName},${index})`;\n                if (index < parsedArrayBindingElements.length - 1) {\n                    arrayBindingStatement += statement + \";\\n\";\n                } else {\n                    // printStatement adds the last ;\n                    arrayBindingStatement += statement;\n                }\n            });\n\n            return arrayBindingStatement;\n        }\n\n        if (declaration?.initializer?.kind=== ts.SyntaxKind.AwaitExpression) {\n            const parsedName = this.printNode(declaration.name, 0);\n            const parsedInitializer = this.printNode(declaration.initializer, 0);\n            return `\n${this.getIden(identation)}${parsedName}:= ${parsedInitializer}\n${this.getIden(identation)}PanicOnError(${parsedName})`;\n\n        }\n\n        const isNew = declaration.initializer && (declaration.initializer.kind === ts.SyntaxKind.NewExpression);\n\n        const parsedValue = (declaration.initializer) ? this.printNode(declaration.initializer, identation) : this.NULL_TOKEN;\n\n        if (parsedValue === this.UNDEFINED_TOKEN) {\n            return this.getIden(identation) + \"var \" + this.printNode(declaration.name) + \" interface{} = \" + parsedValue;\n        }\n\n        if (node?.parent?.kind === ts.SyntaxKind.FirstStatement) {\n            if (isNew) {\n                return this.getIden(identation) + this.printNode(declaration.name) + \" := \" + parsedValue;\n            }\n            const varName = this.printNode(declaration.name);\n            const stm = this.getIden(identation) + \"var \" + varName + \" interface{} = \" + parsedValue;\n            if (parsedValue.startsWith(\"<-this.callInternal(\")) {\n                return `\n${stm}\n${this.getIden(identation)}PanicOnError(${varName})`;\n            }\n            return stm;\n        }\n\n        return this.getIden(identation) + this.printNode(declaration.name) + \" := \" + parsedValue.trim();\n    }\n\n    // printObjectLiteralExpression(node, identation) {\n    //     const objectCreation = 'make(map[string]interface{}) {';\n    //     let formattedObjectBody = '{}';\n    //     if (node.properties?.length > 0) {\n    //         const objectBody = this.printObjectLiteralBody(node, identation);\n    //         formattedObjectBody = objectBody ? \"\\n\" + objectBody + \"\\n\" + this.getIden(identation) : objectBody;\n    //     }\n    //     // return  this.OBJECT_OPENING + formattedObjectBody + this.OBJECT_CLOSING;\n    //     return objectCreation + formattedObjectBody;\n    // }\n\n    // printObjectLiteralBody(node, identation) {\n    //     let objectName = node.parent?.name?.escapedText;\n    //     if (objectName === undefined) {\n    //         objectName = \"object\";\n    //     }\n    //     const body =  node.properties.map((p) => `${this.getIden(identation)}${objectName}[\"${node.properties[0].name.text}\"] = ${p.initializer.text}` ).join(\"\\n\");\n    //     return body;\n    // }\n\n    printConstructorDeclaration (node, identation) {\n        const classNode = node.parent;\n        const className = this.printNode(classNode.name, 0);\n        const args = this.printMethodParameters(node);\n        const constructorBody = this.printFunctionBody(node, identation);\n\n        // find super call inside constructor and extract params\n        let superCallParams = '';\n        let hasSuperCall = false;\n        node.body?.statements.forEach(statement => {\n            if (ts.isExpressionStatement(statement)) {\n                const expression = statement.expression;\n                if (ts.isCallExpression(expression)) {\n                    const expressionText = expression.expression.getText().trim();\n                    if (expressionText === 'super') {\n                        hasSuperCall = true;\n                        superCallParams = expression.arguments.map((a) => {\n                            return this.printNode(a, identation).trim();\n                        }).join(\", \");\n                    }\n                }\n            }\n        });\n\n        if (hasSuperCall) {\n            return this.getIden(identation) + className +\n                `(${args}) : ${this.SUPER_CALL_TOKEN}(${superCallParams})` +\n                constructorBody;\n        }\n\n        return this.getIden(identation) +\n                className +\n                \"(\" + args + \")\" +\n                constructorBody;\n    }\n\n    printThisElementAccesssIfNeeded(node, identation) {\n        // convert this[method] into this.call(method) or this.callAsync(method)\n        // const isAsync = node?.parent?.kind === ts.SyntaxKind.AwaitExpression;\n        const isAsync = true; // setting to true for now, because there are some scenarios where we don't know\n        // if the call is async or not, so we need to assume it is async\n        // example Promise.all([this.unknownPropAsync()])\n        const elementAccess = node.expression;\n        if (elementAccess?.kind === ts.SyntaxKind.ElementAccessExpression) {\n            if (elementAccess?.expression?.kind === ts.SyntaxKind.ThisKeyword) {\n                let parsedArg = node.arguments?.length > 0 ? this.printNode(node.arguments[0], identation).trimStart() : \"\";\n                const propName = this.printNode(elementAccess.argumentExpression, 0);\n                const wrapperOpen = isAsync ? this.UKNOWN_PROP_ASYNC_WRAPPER_OPEN : this.UKNOWN_PROP_WRAPPER_OPEN;\n                const wrapperClose = isAsync ? this.UNKOWN_PROP_ASYNC_WRAPPER_CLOSE : this.UNKOWN_PROP_WRAPPER_CLOSE;\n                parsedArg = parsedArg ? \", \" + parsedArg : \"\";\n                return wrapperOpen + propName + parsedArg + wrapperClose;\n            }\n        }\n        return;\n    }\n\n    printDynamicCall(node, identation) {\n        // const isAsync = true; // setting to true for now, because there are some scenarios where we don't know\n        const elementAccess = node.expression;\n        if (elementAccess?.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const parsedArg = node.arguments?.length > 0 ? node.arguments.map(n => this.printNode(n, identation).trimStart()).join(\", \") : \"\";\n            // const target = this.printNode(elementAccess.expression, 0);\n            const propName = this.printNode(elementAccess.argumentExpression, 0);\n            const argsArray = `${parsedArg}`;\n            const open = this.DYNAMIC_CALL_OPEN;\n            const statement = `${open}${propName}, ${argsArray})`;\n            // statement = isAsync ? `((Task<object>)${statement})` : statement;\n            return statement;\n        }\n        return undefined;\n    }\n\n\n    printElementAccessExpressionExceptionIfAny(node) {\n        // Fix malformed Split(...) element access where the index arg is mistakenly placed\n        // inside the Split call. We force the correct pattern: GetValue(Split(str, sep), idx)\n        const tsKind = ts.SyntaxKind;\n        if (node.expression.kind === tsKind.CallExpression) {\n            const callExp = node.expression;\n            const calleeText = callExp.expression.getText();\n            if (calleeText.endsWith('.split') || calleeText.toLowerCase().includes('split')) {\n                // print Split call normally (should already close with ))\n                let splitCall = this.printNode(callExp, 0).trim();\n                if (!splitCall.endsWith(')')) {\n                    splitCall += ')';\n                }\n                const idxArg = this.printNode(node.argumentExpression, 0);\n                return `GetValue(${splitCall}, ${idxArg})`;\n            }\n        }\n        // default: no exception\n        return undefined;\n    }\n\n    printWrappedUnknownThisProperty(node) {\n        const type = global.checker.getResolvedSignature(node);\n        if (type?.declaration === undefined) {\n            let parsedArguments = node.arguments?.map((a) => this.printNode(a, 0)).join(\", \");\n            parsedArguments = parsedArguments ? parsedArguments : \"\";\n            const propName = node.expression?.name.escapedText;\n            // const isAsyncDecl = true;\n            // const isAsyncDecl = node?.parent?.kind === ts.SyntaxKind.AwaitExpression;\n            // const isAsyncDecl = false;\n            // const open = isAsyncDecl ? this.UKNOWN_PROP_ASYNC_WRAPPER_OPEN : this.UKNOWN_PROP_WRAPPER_OPEN;\n            // const close = this.UNKOWN_PROP_WRAPPER_CLOSE;\n            // return `${open}\"${propName}\"${parsedArguments}${close}`;\n            const argsArray = `${parsedArguments}`;\n            const open = this.DYNAMIC_CALL_OPEN;\n            const statement = `${open}\"${propName}\", ${argsArray})`;\n            return statement;\n        }\n        return undefined;\n    }\n\n    transformMethodNameIfNeeded(name: string): string {\n        const res = this.unCamelCaseIfNeeded(name);\n        return this.capitalize(res);\n    }\n\n    transformCallExpressionName(name: string) {\n        return this.capitalize(name);\n    }\n\n    transformPropertyAccessExpressionName(name: string) {\n        return this.capitalize(name);\n    }\n\n    printOutOfOrderCallExpressionIfAny(node, identation) {\n        if (node.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const args = node.arguments;\n\n            if (node.expression.expression.kind === ts.SyntaxKind.ThisKeyword) {\n                const methodName = this.printNode(node.expression.name, 0);\n                if (this.wrapThisCalls || (this.wrapCallMethods.includes(methodName))) {\n                    let argsParsed = \"\";\n                    if (args.length > 0) {\n                        argsParsed = args.map((a) => this.printNode(a, 0)).join(\", \");\n                        return `<-this.callInternal(\"${methodName}\", ${argsParsed})`;\n                    }\n                    return `<-this.callInternal(\"${methodName}\")`;\n                }\n            }\n\n            const expressionText = node.expression.getText().trim();\n            if (args.length === 1) {\n                const parsedArg = this.printNode(args[0], 0);\n                switch (expressionText) {\n                // case \"JSON.parse\":\n                //     return `json_decode(${parsedArg}, $as_associative_array = true)`;\n                case \"Math.abs\":\n                    return `mathAbs(${parsedArg})`;\n                }\n            } else if (args.length === 2)\n            {\n                const parsedArg1 = this.printNode(args[0], 0);\n                const parsedArg2 = this.printNode(args[1], 0);\n                switch (expressionText) {\n                case \"Math.min\":\n                    return `mathMin(${parsedArg1}, ${parsedArg2})`;\n                case \"Math.max\":\n                    return `mathMax(${parsedArg1}, ${parsedArg2})`;\n                case \"Math.pow\":\n                    return `MathPow(${parsedArg1}, ${parsedArg2})`;\n                }\n            }\n            const leftSide = node.expression?.expression;\n            const leftSideText = leftSide ? this.printNode(leftSide, 0) : undefined;\n\n            // wrap unknown property this.X calls\n            if (leftSideText === this.THIS_TOKEN || leftSide.getFullText().indexOf(\"(this as any)\") > -1) { // double check this\n                const res = this.printWrappedUnknownThisProperty(node);\n                if (res) {\n                    return res;\n                }\n            }\n        }\n\n        // // replace this[method]() calls\n        // const thisElementAccess = this.printThisElementAccesssIfNeeded(node, identation);\n        // if (thisElementAccess) {\n        //     return thisElementAccess;\n        // }\n\n        // handle dynamic calls, this[method](A) or exchange[b] (c) using reflection\n        if (node.expression.kind === ts.SyntaxKind.ElementAccessExpression) {\n            return this.printDynamicCall(node, identation);\n        }\n\n\n        return undefined;\n    }\n\n    handleTypeOfInsideBinaryExpression(node, identation) {\n        const left = node.left;\n        const right = node.right.text;\n        const op = node.operatorToken.kind;\n        const expression = left.expression;\n\n        const isDifferentOperator = op === ts.SyntaxKind.ExclamationEqualsEqualsToken || op === ts.SyntaxKind.ExclamationEqualsToken;\n        const notOperator = isDifferentOperator ? this.NOT_TOKEN : \"\";\n\n        const target = this.printNode(expression, 0);\n        switch (right) {\n        case \"string\":\n            return notOperator + `IsString(${target})`;\n        case \"number\":\n            return notOperator + `IsNumber(${target})`;\n        case \"boolean\":\n            return notOperator + `IsBool(${target})`;\n        case \"object\":\n            return notOperator + `IsObject(${target})`;\n        case \"function\":\n            return notOperator + `IsFunction(${target})`;\n        }\n\n        return undefined;\n\n    }\n\n    printCustomBinaryExpressionIfAny(node, identation) {\n        const left = node.left;\n        const right = node.right;\n\n        const op = node.operatorToken.kind;\n\n        // ---------------------------------------------------------------\n        // Array destructuring assignment:  [a, b] = foo()\n        // Transforms into:\n        // __tmpX := foo()\n        // a = GetValue(__tmpX, 0)\n        // b = GetValue(__tmpX, 1)\n        // ---------------------------------------------------------------\n        if (op === ts.SyntaxKind.EqualsToken &&\n            left.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            // const elems = (left.elements as any[]);\n            // const returnRandName = \"retRes\" + this.getLineBasedSuffix(node);\n            // const rhs   = this.printNode(right, 0);\n\n            // // build extraction lines\n            // const assignments = elems.map((el, idx) => {\n            //     const leftName = this.printNode(el, 0);\n            //     return `${leftName} = GetValue(${returnRandName}, ${idx})`;\n            // }).join(`\\n${this.getIden(identation)}`);\n\n            // return `${returnRandName} := ${rhs}\\n${this.getIden(identation)}${assignments}`;\n            //\n            const arrayBindingPatternElements = left.elements;\n            const parsedArrayBindingElements = arrayBindingPatternElements.map((e) => this.printNode(e, 0));\n            const syntheticName = parsedArrayBindingElements.join(\"\") + \"Variable\";\n\n            let arrayBindingStatement = `${syntheticName} := ${this.printNode(right, 0)};\\n`;\n\n            parsedArrayBindingElements.forEach((e, index) => {\n\n                const statement = this.getIden(identation) + `${e} = GetValue(${syntheticName},${index})`;\n                if (index < parsedArrayBindingElements.length - 1) {\n                    arrayBindingStatement += statement + \";\\n\";\n                } else {\n                    // printStatement adds the last ;\n                    arrayBindingStatement += statement;\n                }\n            });\n\n            return arrayBindingStatement;\n        }\n\n        // ---------------------------------------------------------------\n        // Go-style setter for element-access assignments:  a[b] = v\n        // ---------------------------------------------------------------\n        if (op === ts.SyntaxKind.EqualsToken &&\n            left.kind === ts.SyntaxKind.ElementAccessExpression) {\n            // Collect base container and all keys (inner-most key is last).\n            const keys: any[] = [];\n            let baseExpr: any = null;\n            let cur: any = left;\n            while (ts.isElementAccessExpression(cur)) {\n                keys.unshift(cur.argumentExpression);          // prepend\n                const expr = cur.expression;\n                if (!ts.isElementAccessExpression(expr)) {\n                    baseExpr = expr;\n                    break;\n                }\n                cur = expr;\n            }\n\n            const containerStr = this.printNode(baseExpr, 0);\n            const keyStrs      = keys.map(k => this.printNode(k, 0));\n\n            // Build GetValue(GetValue( ... )) chain for all but the last key.\n            let acc = containerStr;\n            for (let i = 0; i < keyStrs.length - 1; i++) {\n                acc = `${this.ELEMENT_ACCESS_WRAPPER_OPEN}${acc}, ${keyStrs[i]}${this.ELEMENT_ACCESS_WRAPPER_CLOSE}`;\n            }\n\n            const lastKey = keyStrs[keyStrs.length - 1];\n            const rhs     = this.printNode(right, 0);\n\n            return `AddElementToObject(${acc}, ${lastKey}, ${rhs})`;\n        }\n\n        // ---------------------------------------------------------------\n        // Go-style setter for element-access compound assignments:  a[b] += v\n        // ---------------------------------------------------------------\n        if (op === ts.SyntaxKind.PlusEqualsToken &&\n            left.kind === ts.SyntaxKind.ElementAccessExpression) {\n            // Collect base container and all keys (inner-most key is last).\n            const keys: any[] = [];\n            let baseExpr: any = null;\n            let cur: any = left;\n            while (ts.isElementAccessExpression(cur)) {\n                keys.unshift(cur.argumentExpression);          // prepend\n                const expr = cur.expression;\n                if (!ts.isElementAccessExpression(expr)) {\n                    baseExpr = expr;\n                    break;\n                }\n                cur = expr;\n            }\n\n            const containerStr = this.printNode(baseExpr, 0);\n            const keyStrs      = keys.map(k => this.printNode(k, 0));\n\n            // Build GetValue(GetValue( ... )) chain for all but the last key.\n            let acc = containerStr;\n            for (let i = 0; i < keyStrs.length - 1; i++) {\n                acc = `${this.ELEMENT_ACCESS_WRAPPER_OPEN}${acc}, ${keyStrs[i]}${this.ELEMENT_ACCESS_WRAPPER_CLOSE}`;\n            }\n\n            const lastKey = keyStrs[keyStrs.length - 1];\n            const rhs     = this.printNode(right, 0);\n\n            // For +=, we need to get the current value, add to it, then set it back\n            const currentValue = `${this.ELEMENT_ACCESS_WRAPPER_OPEN}${acc}, ${lastKey}${this.ELEMENT_ACCESS_WRAPPER_CLOSE}`;\n            const result = `AddElementToObject(${acc}, ${lastKey}, Add(${currentValue}, ${rhs}))`;\n            return result;\n        }\n\n        if (left.kind === ts.SyntaxKind.TypeOfExpression) {\n            const typeOfExpression = this.handleTypeOfInsideBinaryExpression(node, identation);\n            if (typeOfExpression) {\n                return typeOfExpression;\n            }\n        }\n\n        if (op === ts.SyntaxKind.InKeyword) {\n            return `InOp(${this.printNode(right, 0)}, ${this.printNode(left, 0)})`;\n        }\n\n        const leftText = this.printNode(left, 0);\n        const rightText = this.printNode(right, 0);\n\n        if (op === ts.SyntaxKind.PlusEqualsToken) {\n            return `${leftText} = Add(${leftText}, ${rightText})`;\n        }\n\n        if (op === ts.SyntaxKind.MinusEqualsToken) {\n            return `${leftText} = Subtract(${leftText}, ${rightText})`;\n        }\n\n\n        if (op in this.binaryExpressionsWrappers) {\n            const wrapper = this.binaryExpressionsWrappers[op];\n            const open = wrapper[0];\n            const close = wrapper[1];\n            return `${open}${leftText}, ${rightText}${close}`;\n        }\n\n        // x = y\n        // cast y to x type when y is unknown\n        // if (op === ts.SyntaxKind.EqualsToken) {\n        //     const leftType = global.checker.getTypeAtLocation(left);\n        //     const rightType = global.checker.getTypeAtLocation(right);\n\n        //     if (this.isAnyType(rightType.flags) && !this.isAnyType(leftType.flags)) {\n        //         // const parsedType = this.getTypeFromRawType(leftType);\n        //         return `${leftText} = ${rightText}`;\n        //     }\n        // }\n\n        return undefined;\n    }\n\n    // castVariableAssignmentIfNeeded(left, right, identation) {\n    //     const leftType = global.checker.getTypeAtLocation(left);\n    //     const rightType = global.checker.getTypeAtLocation(right);\n\n    //     const leftText = this.printNode(left, 0);\n    //     const rightText = this.printNode(right, 0);\n\n    //     if (this.isAnyType(rightType.flags) && !this.isAnyType(leftType.flags)) {\n    //         const parsedType = this.getTypeFromRawType(leftType);\n    //         return `${this.getIden(identation)}${leftText} = (${parsedType})${rightText}`;\n    //     }\n    //     return undefined;\n    // }\n\n    transformPropertyAcessExpressionIfNeeded(node) {\n        const expression = node.expression;\n        const leftSide = this.printNode(expression, 0);\n        const rightSide = node.name.escapedText;\n\n        let rawExpression = undefined;\n\n        switch(rightSide) {\n        case 'length':\n                const type = (global.checker as TypeChecker).getTypeAtLocation(expression); // eslint-disable-line\n            // this.warnIfAnyType(node, type.flags, leftSide, \"length\");\n            // rawExpression = this.isStringType(type.flags) ? `(string${leftSide}).Length` : `(${leftSide}.Cast<object>().ToList()).Count`;\n            rawExpression = this.isStringType(type.flags) ? `GetLength(${leftSide})` : `${this.ARRAY_LENGTH_WRAPPER_OPEN}${leftSide}${this.ARRAY_LENGTH_WRAPPER_CLOSE}`; // `(${leftSide}.Cast<object>()).ToList().Count`\n            break;\n        case 'push':\n            rawExpression = `((IList<object>)${leftSide}).Add`;\n            break;\n            // case 'push':\n            //     rawExpression = `(List<object>${leftSide}).Add`s\n            //     break;\n        }\n        return rawExpression;\n    }\n\n    printCustomDefaultValueIfNeeded(node) {\n        return undefined;\n    }\n\n    printFunctionBody(node, identation, wrapInChannel = false) {\n\n        // check if there is any default parameter to initialize\n        let functionBody: string;\n        const funcParams = node.parameters;\n        const initParams = [];\n        if (funcParams.length > 0) {\n            const body = node.body.statements;\n            const first = body.length > 0 ? body[0] : [];\n            const remaining = body.length > 0 ? body.slice(1): [];\n            let firstStatement = this.printNode(first, identation + 1);\n\n            const remainingString = remaining.map((statement) => this.printNode(statement, identation + 1)).join(\"\\n\");\n            let offSetIndex = 0;\n            funcParams.forEach((param, i) => {\n                const initializer = param.initializer;\n                if (initializer) {\n                    const index = i + offSetIndex;\n                    // index = index < 0 ? 0 : i - 1;\n                    const paramName = this.printNode(param.name, 0);\n                    initParams.push(`${paramName} := GetArg(optionalArgs, ${index}, ${this.printNode(initializer, 0)})`);\n                    initParams.push(`_ = ${paramName}`);\n                } else {\n                    offSetIndex--;\n                }\n            });\n\n            if (initParams.length > 0) {\n                const defaultInitializers = initParams.map( l => this.getIden(identation+1) + l ).join(\"\\n\") + \"\\n\";\n                const bodyParts = firstStatement.split(\"\\n\");\n                const commentPart = bodyParts.filter(line => this.isComment(line));\n                const isComment = commentPart.length > 0;\n                if (isComment) {\n                    const commentPartString = commentPart.map((c) => this.getIden(identation+1) + c.trim()).join(\"\\n\");\n                    const firstStmNoComment = bodyParts.filter(line => !this.isComment(line)).join(\"\\n\");\n                    firstStatement = commentPartString + \"\\n\" + defaultInitializers + firstStmNoComment;\n                } else {\n                    firstStatement = defaultInitializers + firstStatement;\n                }\n            }\n            const blockOpen = this.getBlockOpen(identation);\n            const blockClose = this.getBlockClose(identation);\n            firstStatement = remainingString.length > 0 ? firstStatement + \"\\n\" : firstStatement;\n            if (!wrapInChannel) {\n                functionBody = blockOpen + firstStatement + remainingString + blockClose;\n            } else {\n                functionBody = firstStatement + remainingString;\n            }\n        } else {\n            if (!wrapInChannel) {\n                functionBody = super.printFunctionBody(node, identation);\n            } else {\n                functionBody = node.body.statements.map(statement => {\n                    // if (statement.kind === ts.SyntaxKind.ReturnStatement) {\n                    //     if (statement?.expression) {\n                    //         return this.getIden(identation) + \"ch <-\" + this.printNode(statement.expression) + '\\n' + this.getIden(identation) + \"return \" + this.printNode(statement.expression);\n                    //     }\n                    // }\n                    return this.printNode(statement, identation);\n                }).join(\"\\n\");\n\n            }\n        }\n        if (wrapInChannel) {\n            // return statement might be inside ifs or other complex statements so we still have to replace them manually :(\n            // functionBody = functionBody.replace(/(\\s*)return\\s+([^\\n]+\\n?)/g, '$1ch <- $2$1');\n            const functionBodySplit = functionBody.split(\"\\n\");\n            const bodyWithIndentationExtraAndNoReturn = functionBodySplit.map((line) => {\n\n                const trimmedLine = line.trim();\n\n                // should we do this inside printReturn statement?\n                // if(trimmedLine.startsWith(\"return\") && trimmedLine !== \"return\") {\n                //     const returnIndentation = line.indexOf(\"return\")/4 + this.getIden(1);\n                //     let channelReturn = this.getIden(returnIndentation) + \"ch <-\" + line.replace(\"return\", \"\").trimStart();\n                //     if (trimmedLine === \"return nil\") {\n                //         channelReturn = this.getIden(returnIndentation) + \"ch <- nil\\n\" + this.getIden(returnIndentation) + \"return nil\";\n                //         // it's hard because we don't want to remove the treturns from the emulated try-catches we have that are also functions\n                //         // with return statements\n                //     }\n                //     return channelReturn;\n                // }\n                return this.getIden(identation+2) + line;\n            }).join(\"\\n\");\n            let shouldAddLastReturn = true;\n\n            // const bodySplit = bodyWithIndentationExtraAndNoReturn.split(\"\\n\");\n            const bodySplit = functionBodySplit;\n            const lastLine = bodySplit[bodySplit.length - 1];\n            if (lastLine.trim().startsWith(\"return\") || lastLine.trim().startsWith(\"panic\")) {\n                shouldAddLastReturn = false;\n            }\n\n            // Check if the function body ends with a conditional that has returns in all branches\n            if (node.body && this.blockEndsWithConditionalReturn(node.body.statements)) {\n                shouldAddLastReturn = false;\n            }\n\n            const lastReturn = shouldAddLastReturn ? this.getIden(identation+2) + \"return nil\" : \"\";\n            // const hasCatchInside = bodySplit.indexOf(\"recover()\") > -1;\n            // if ((1+1 == 2) || hasCatchInside) {\n            functionBody = `{\n        ${this.getIden(identation + 1)}ch := make(chan ${this.DEFAULT_RETURN_TYPE})\n        ${this.getIden(identation + 1)}go func() interface{} {\n        ${this.getIden(identation + 2)}defer close(ch)\n        ${this.getIden(identation + 2)}defer ReturnPanicError(ch)\n        ${bodyWithIndentationExtraAndNoReturn}\n        ${lastReturn}\n        ${this.getIden(identation + 1)}}()\n        ${this.getIden(identation + 1)}return ch\n        ${this.getIden(identation)}}`;\n            // } else {\n            // functionBody = `{\n            // ${id1}ch := make(chan ${this.DEFAULT_RETURN_TYPE})\n            // ${id1}var panicError interface{} = nil\n            // ${id1}var wg sync.WaitGroup\n            // ${id1}wg.Add(1)\n            // ${id1}go func() interface{} {\n            // ${id2}defer wg.Done()\n            // ${id2}defer close(ch)\n            // ${id2}defer func() {\n            // ${id3}if r := recover(); r != nil {\n            // ${id4}panicError = r\n            // ${id4}return\n            // ${id3}}\n            // ${id2}}()\n            // ${bodySplit}\n            // ${lastReturn}\n            // ${id1}}()\n            // ${id1}wg.Wait()\n            // ${id1}if panicError != nil {\n            // ${id2}panic(panicError)\n            // ${id1}}\n            // ${id1}return ch\n            // ${id}}`;\n            // }\n\n            // to do fix this later\n            // we can't pass nil to the channel when we just want to\n            // return from the try catch, otherwise the channel will close with nil\n            // instead of the proper result\n            functionBody = functionBody.replaceAll(/(^\\s*)ch\\s<-\\snil\\s+return\\snil(\\s*\\})/gm, \"$1return nil$2\");\n\n        }\n\n        return functionBody;\n    }\n\n    printAwaitExpression(node, identation) {\n        const expression = this.printNode(node.expression, identation);\n        if (expression.startsWith(\"<-\")) {\n            return expression;\n        }\n        return `(<-${expression})`;\n    }\n\n    printInstanceOfExpression(node: BinaryExpression, identation: number): string {\n        const left = this.printNode (node.left);\n        const right = this.printNode (node.right);\n        return this.getIden(identation) + `IsInstance(${left}, ${right})`;\n    }\n\n    getRandomNameSuffix() {\n        return Math.floor(Math.random() * 1000000).toString();\n    }\n\n    getLineBasedSuffix(node): string {\n        const { line, character } = global.src.getLineAndCharacterOfPosition(node.getStart());\n        return `${line}${character}`;\n    }\n\n    printExpressionStatement(node, identation) {\n\n        if (node?.expression?.kind === ts.SyntaxKind.AsExpression) {\n            node = node.expression;\n        }\n        if (node.expression.kind !== ts.SyntaxKind.AwaitExpression) {\n            return super.printExpressionStatement(node, identation);\n        }\n\n        const exprStm = this.printNode(node.expression, identation);\n\n        // const { line, character } = global.src.getLineAndCharacterOfPosition(node.getStart());\n        // console.log(`line: ${line}, character: ${character}`);\n        const returnRandName = \"retRes\" + this.getLineBasedSuffix(node);\n\n        // const expStatement =this.getIden(identation) + exprStm + this.LINE_TERMINATOR;\n\n        const expStatement = `\n${this.getIden(identation)}${returnRandName} := ${exprStm}\n${this.getIden(identation)}PanicOnError(${returnRandName})`;\n        return this.printNodeCommentsIfAny(node, identation, expStatement);\n    }\n\n    isInsideAsyncFunction(returnStatementNode) {\n        let currentNode = returnStatementNode;\n\n        while (currentNode) {\n            // Check if the current node is a function or method\n            if (ts.isFunctionDeclaration(currentNode) ||\n              ts.isFunctionExpression(currentNode) ||\n              ts.isArrowFunction(currentNode) ||\n              ts.isMethodDeclaration(currentNode)) {\n                return currentNode.modifiers && currentNode.modifiers.some(modifier => modifier.kind === ts.SyntaxKind.AsyncKeyword);\n            }\n            // Move up the tree to the parent node\n            currentNode = currentNode.parent;\n        }\n\n        // Return false if no async function or method is found\n        return false;\n    }\n\n    printReturnStatement(node, identation) {\n\n        const isAsyncFunction = this.isInsideAsyncFunction(node);\n        // if (node?.expression?.kind !== ts.SyntaxKind.AwaitExpression) {\n        //     return super.printReturnStatement(node, identation);\n        // }\n        if (!isAsyncFunction) {\n            return super.printReturnStatement(node, identation);\n        }\n\n        const leadingComment = this.printLeadingComments(node, identation);\n        let trailingComment = this.printTraillingComment(node, identation);\n        trailingComment = trailingComment ? \" \" + trailingComment : trailingComment;\n        const exp =  node.expression;\n        let rightPart = exp ? (' ' + this.printNode(exp, identation)) : '';\n        rightPart = rightPart.trim();\n\n        if (node?.expression?.kind === ts.SyntaxKind.AsExpression) {\n            node = node.expression;\n        }\n\n        if (node?.expression?.kind === ts.SyntaxKind.AwaitExpression) {\n            // const returnRandName = \"retRes\" + this.getRandomNameSuffix();\n            const returnRandName = \"retRes\" + this.getLineBasedSuffix(node.expression);\n            rightPart = rightPart ? ' ' + rightPart + this.LINE_TERMINATOR : this.LINE_TERMINATOR;\n            // return leadingComment + this.getIden(identation) + this.RETURN_TOKEN + rightPart + trailingComment;\n            return `\n    ${this.getIden(identation)}${returnRandName} := ${rightPart}\n    ${this.getIden(identation)}PanicOnError(${returnRandName})\n    ${this.getIden(identation)}${leadingComment}ch <- ${returnRandName}${trailingComment}\n    ${this.getIden(identation)}return nil`;\n            // ${this.getIden(identation)}return ${returnRandName}`;\n        }\n\n        if (rightPart.length === 0) {\n            return `\\n${this.getIden(identation)}return nil`;\n        }\n\n        return `\n${this.getIden(identation)}${leadingComment}ch <- ${rightPart}${trailingComment}\n${this.getIden(identation)}return nil`;\n        // ${this.getIden(identation)}return ${rightPart}`;\n        // ${this.getIden(identation)}return ${rightPart}`;\n    }\n\n\n    printAsExpression(node, identation) {\n        const type = node.type;\n\n        if (type.kind === ts.SyntaxKind.AnyKeyword) {\n            // return `(()${this.printNode(node.expression, identation)})`;\n        }\n\n        if (type.kind === ts.SyntaxKind.StringKeyword) {\n            // return `((string)${this.printNode(node.expression, identation)})`;\n        }\n\n        if (type.kind === ts.SyntaxKind.ArrayType) {\n            // if (type.elementType.kind === ts.SyntaxKind.AnyKeyword) {\n            //     return `(IList<object>)(${this.printNode(node.expression, identation)})`;\n            // }\n            // if (type.elementType.kind === ts.SyntaxKind.StringKeyword) {\n            //     return `(IList<string>)(${this.printNode(node.expression, identation)})`;\n            // }\n        }\n\n        return this.printNode(node.expression, identation);\n    }\n\n    printArrayLiteralExpression(node) {\n\n        let arrayOpen = this.ARRAY_OPENING_TOKEN;\n        const elems = node.elements;\n\n        const elements = node.elements.map((e) => {\n            return this.printNode(e);\n        }).join(\", \");\n\n        // take into consideration list of promises\n        if (elems.length > 0) {\n            const first = elems[0];\n            if (first.kind === ts.SyntaxKind.CallExpression) {\n                // const type = global.checker.getTypeAtLocation(first);\n                const type = this.getFunctionType(first);\n                // const parsedType = this.getTypeFromRawType(type);\n                // parsedType === \"Task\" ||\n                // to do check this later\n                if (type === undefined || elements.indexOf(this.UKNOWN_PROP_ASYNC_WRAPPER_OPEN) > -1) {\n                    // if (type === undefined) {\n                    arrayOpen = \"[]interface{}{\";\n                    // }\n                    //  else {\n                    //     arrayOpen = \"new List<Task<object>> {\";\n                    // }\n                } else {\n                    // type = 'object';\n                    // check this out later\n                    // if (type === 'Task<List<object>>') {\n                    //     type = 'Task<object>';\n                    // }\n                    // if (type === 'string'){\n                    //     type = 'object';\n                    // }\n                    // type =\n                    arrayOpen = `[]interface{}{`;\n                }\n            }\n        }\n\n        return arrayOpen + elements + this.ARRAY_CLOSING_TOKEN;\n    }\n\n    printArgsForCallExpression(node, identation) {\n        const args = node.arguments;\n        let parsedArgs  = \"\";\n        if (false && this.requiresCallExpressionCast && !this.isBuiltInFunctionCall(node?.expression)) { //eslint-disable-line\n            const parsedTypes = this.getTypesFromCallExpressionParameters(node);\n            const tmpArgs = [];\n            args.forEach((arg, index) => {\n                const parsedType = parsedTypes[index];\n                let cast = \"\";\n                if (parsedType !== \"object\" && parsedType !== \"float\" && parsedType !== \"int\") {\n                    cast = parsedType ? `(${parsedType})` : '';\n                }\n                tmpArgs.push(cast + this.printNode(arg, identation).trim());\n            });\n            parsedArgs = tmpArgs.join(\",\");\n            return parsedArgs;\n        }\n        return super.printArgsForCallExpression(node, identation);\n    }\n\n    // check this out later\n\n    printArrayIsArrayCall(node, identation, parsedArg = undefined) {\n        return `IsArray(${parsedArg})`;\n    }\n\n    printObjectKeysCall(node, identation, parsedArg = undefined) {\n        return `ObjectKeys(${parsedArg})`;\n    }\n\n    printObjectValuesCall(node, identation, parsedArg = undefined) {\n        return `ObjectValues(${parsedArg})`;\n    }\n\n    printJsonParseCall(node, identation, parsedArg = undefined) {\n        return `JsonParse(${parsedArg})`;\n    }\n\n    printJsonStringifyCall(node, identation, parsedArg = undefined) {\n        return `JsonStringify(${parsedArg})`; // make this customizable\n    }\n\n    printPromiseAllCall(node, identation, parsedArg = undefined) {\n        return `promiseAll(${parsedArg})`;\n    }\n\n    printMathFloorCall(node, identation, parsedArg = undefined) {\n        return `MathFloor(${parsedArg})`;\n    }\n\n    printMathRoundCall(node, identation, parsedArg = undefined) {\n        return `MathRound(${parsedArg})`;\n    }\n\n    printMathCeilCall(node, identation, parsedArg = undefined) {\n        return `MathCeil(${parsedArg})`;\n    }\n\n    printNumberIsIntegerCall(node: any, identation: any, parsedArg?: any) {\n        return `IsInt(${parsedArg})`;\n    }\n\n    printArrayPushCall(node: CallExpression, identation: number, name: string | undefined = undefined, parsedArg: string | undefined = undefined) {\n        let returnValue = '';\n        let returnRandName = name;\n        if (name?.startsWith('GetValue')) {\n            returnRandName = \"retRes\" + this.getLineBasedSuffix(node);\n            returnValue = `${returnRandName} := ${name}\\n${this.getIden(identation)}`;\n        }\n        return  `${returnValue}AppendToArray(&${returnRandName}, ${parsedArg})`;\n        // works with:\n        //  func AppendToArray(slicePtr *interface{}, element interface{})\n        //  func AppendToArrayValue(slice interface{}, element interface{}) interface{}\n        //  func AppendToArraySafe(slice interface{}, element interface{}) interface{}\n    }\n\n    printIncludesCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `Contains(${name},${parsedArg})`;\n    }\n\n    printIndexOfCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `${this.INDEXOF_WRAPPER_OPEN}${name}, ${parsedArg}${this.INDEXOF_WRAPPER_CLOSE}`;\n    }\n\n    printStartsWithCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `StartsWith(${name}, ${parsedArg})`;\n    }\n\n    printEndsWithCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `EndsWith(${name}, ${parsedArg})`;\n    }\n\n    printTrimCall(node, identation, name = undefined) {\n        return `Trim(${name})`;\n    }\n\n    printJoinCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `Join(${name}, ${parsedArg})`;\n    }\n\n    printSplitCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `Split(${name}, ${parsedArg})`;\n    }\n\n    printToFixedCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `toFixed(${name}, ${parsedArg})`;\n    }\n\n    printToStringCall(node, identation, name = undefined) {\n        return `ToString(${name})`;\n    }\n\n    printConcatCall(node, identation, name = undefined, parsedArg = undefined) {\n        return `Concat(${name}, ${parsedArg})`;\n    }\n\n    printToUpperCaseCall(node, identation, name = undefined) {\n        return `ToUpper(${name})`;\n    }\n\n    printToLowerCaseCall(node, identation, name = undefined) {\n        return `ToLower(${name})`;\n    }\n\n    printShiftCall(node, identation, name = undefined) {\n        return `Shift(${name})`;\n    }\n\n    printReverseCall(node, identation, name = undefined) {\n        return `Reverse(${name})`;\n    }\n\n    printPopCall(node, identation, name = undefined) {\n        return `Pop(${name}))`;\n    }\n\n    printAssertCall(node, identation, parsedArgs) {\n        return `assert(${parsedArgs})`;\n    }\n\n    printSliceCall(node, identation, name = undefined, parsedArg = undefined, parsedArg2 = undefined) {\n        if (parsedArg2 === undefined){\n            // return `((string)${name}).Substring((int)${parsedArg})`;\n            parsedArg2 = 'nil';\n        }\n        // return `((string)${name})[((int)${parsedArg})..((int)${parsedArg2})]`;\n        return `Slice(${name}, ${parsedArg}, ${parsedArg2})`;\n    }\n\n    printReplaceCall(node, identation, name = undefined, parsedArg = undefined, parsedArg2 = undefined) {\n        return `Replace(${name}, ${parsedArg}, ${parsedArg2})`;\n    }\n\n    printReplaceAllCall(node, identation, name = undefined, parsedArg = undefined, parsedArg2 = undefined) {\n        return `Replace(${name}, ${parsedArg}, ${parsedArg2})`;\n    }\n\n    printPadEndCall(node, identation, name, parsedArg, parsedArg2) {\n        return `PadEnd(${name}, ${parsedArg}, ${parsedArg2})`;\n    }\n\n    printPadStartCall(node, identation, name, parsedArg, parsedArg2) {\n        return `PadStart(${name}, ${parsedArg}, ${parsedArg2})`;\n    }\n\n    printDateNowCall(node, identation) {\n        return \"DateNow()\";\n    }\n\n    printLengthProperty(node, identation, name = undefined) {\n        const leftSide = this.printNode(node.expression, 0);\n        // const type = (global.checker as TypeChecker).getTypeAtLocation(node.expression); // eslint-disable-line\n        // this.warnIfAnyType(node, type.flags, leftSide, \"length\");\n        return `GetLength(${leftSide})`;\n    }\n\n    // printPostFixUnaryExpression(node, identation) {\n    //     const {operand, operator} = node;\n    //     if (operand.kind === ts.SyntaxKind.NumericLiteral) {\n    //         return super.printPostFixUnaryExpression(node, identation);\n    //     }\n    //     const leftSide = this.printNode(operand, 0);\n    //     const op = this.PostFixOperators[operator]; // todo: handle --\n    //     if (op === '--') {\n    //         return `postFixDecrement(ref ${leftSide})`;\n    //     }\n    //     return `postFixIncrement(ref ${leftSide})`;\n    // }\n\n    // printPrefixUnaryExpression(node, identation) {\n    //     const {operand, operator} = node;\n    //     if (operand.kind === ts.SyntaxKind.NumericLiteral) {\n    //         return super.printPrefixUnaryExpression(node, identation);\n    //     }\n    //     if (operator === ts.SyntaxKind.ExclamationToken) {\n    //         // not branch check falsy/turthy values if needed;\n    //         return  this.PrefixFixOperators[operator] + this.printCondition(node.operand, 0);\n    //     }\n    //     const leftSide = this.printNode(operand, 0);\n    //     if (operator === ts.SyntaxKind.PlusToken) {\n    //         return `prefixUnaryPlus(ref ${leftSide})`;\n    //     } else {\n    //         return `prefixUnaryNeg(ref ${leftSide})`;\n    //     }\n    // }\n\n    printConditionalExpression(node, identation) {\n        const condition = this.printCondition(node.condition, 0);\n        const whenTrue = this.printNode(node.whenTrue, 0);\n        const whenFalse = this.printNode(node.whenFalse, 0);\n\n        return `Ternary(${condition}, ${whenTrue}, ${whenFalse})`;\n    }\n\n    printDeleteExpression(node, identation) {\n        const object = this.printNode (node.expression.expression, 0);\n        const key = this.printNode (node.expression.argumentExpression, 0);\n        return `Remove(${object}, ${key})`;\n    }\n\n    printThrowStatement(node, identation) {\n        // const expression = this.printNode(node.expression, 0);\n        // return this.getIden(node) + this.THROW_TOKEN + \" \" + expression + this.LINE_TERMINATOR;\n        if (node.expression.kind === ts.SyntaxKind.Identifier) {\n            return this.getIden(identation) + 'panic(' + this.printNode(node.expression, 0) + ')' + this.LINE_TERMINATOR;\n        }\n        if (node.expression.kind === ts.SyntaxKind.NewExpression) {\n            const expression = node.expression;\n            // handle throw new Error (Message)\n            // and throw new x[a] (message)\n            const argumentsExp = expression?.arguments ?? [];\n            const parsedArg = argumentsExp.map(n => this.printNode(n, 0)).join(\",\") ?? '';\n            const newExpression =  this.printNode(expression.expression, 0);\n            if (expression.expression.kind === ts.SyntaxKind.Identifier) {\n                // handle throw new X\n                const id = expression.expression;\n                const symbol = global.checker.getSymbolAtLocation(expression.expression);\n                if (symbol) {\n                    const declarations = global.checker.getDeclaredTypeOfSymbol(symbol).symbol?.declarations ?? [];\n                    const isClassDeclaration = declarations.find(l => l.kind === ts.SyntaxKind.InterfaceDeclaration ||  l.kind === ts.SyntaxKind.ClassDeclaration);\n                    if (isClassDeclaration){\n                        // return this.getIden(identation) + `${this.THROW_TOKEN} ${this.NEW_TOKEN} ${id.escapedText} ((string)${parsedArg}) ${this.LINE_TERMINATOR}`;\n                    } else {\n                        return this.getIden(identation) + `throwDynamicException(${id.escapedText}, ${parsedArg});return nil;`;\n                    }\n                }\n                return this.getIden(identation) + `panic(${id.escapedText}(${parsedArg}))${this.LINE_TERMINATOR}`;\n            } else if (expression.expression.kind === ts.SyntaxKind.ElementAccessExpression) {\n                return this.getIden(identation) + `throwDynamicException(${newExpression}, ${parsedArg});`;\n            }\n            return super.printThrowStatement(node, identation);\n        }\n        // const newToken = this.NEW_TOKEN ? this.NEW_TOKEN + \" \" : \"\";\n        // const newExpression = node.expression?.expression?.escapedText;\n        // // newExpression = newExpression ? newExpression : this.printNode(node.expression.expression, 0); // new Exception or new exact[string] check this out\n        // // const args = node.expression?.arguments.map(n => this.printNode(n, 0)).join(\",\");\n        // // const throwExpression = ` ${newToken}${newExpression}${this.LEFT_PARENTHESIS}((string)${args})${this.RIGHT_PARENTHESIS}`;\n        // return this.getIden(identation) + this.THROW_TOKEN + throwExpression + this.LINE_TERMINATOR;\n    }\n\n    printBinaryExpression(node, identation) {\n\n        const {left, right, operatorToken} = node;\n\n        const customBinaryExp = this.printCustomBinaryExpressionIfAny(node, identation);\n        if (customBinaryExp) {\n            return customBinaryExp;\n        }\n\n        if (operatorToken.kind == ts.SyntaxKind.InstanceOfKeyword) {\n            return this.printInstanceOfExpression(node, identation);\n        }\n\n        if (operatorToken.kind === ts.SyntaxKind.EqualsToken) {\n            // handle test['a'] = 1;\n            const elementAccess = left;\n            const rightSide = this.printNode(right, 0);\n            if (left.kind === ts.SyntaxKind.ElementAccessExpression) {\n                const leftSide = this.printNode(elementAccess.expression, 0);\n                const propName = this.printNode(elementAccess.argumentExpression, 0);\n                return `AddElementToObject(${leftSide}, ${propName}, ${rightSide})`;\n            }\n\n            if (right?.kind === ts.SyntaxKind.AwaitExpression || rightSide.startsWith('<-this.callInternal')) {\n                const leftParsed = this.printNode(left, 0);\n                return `\n    ${leftParsed} = ${rightSide}\n    ${this.getIden(identation)}PanicOnError(${leftParsed})`;\n            }\n        }\n\n        const op = operatorToken.kind;\n        // handle: [x,d] = this.method()\n        if (op === ts.SyntaxKind.EqualsToken && left.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayBindingPatternElements = left.elements;\n            const parsedArrayBindingElements = arrayBindingPatternElements.map((e) => this.printNode(e, 0));\n            const syntheticName = parsedArrayBindingElements.join(\"\") + \"Variable\";\n\n            let arrayBindingStatement = `${syntheticName} := ${this.printNode(right, 0)};\\n`;\n\n            parsedArrayBindingElements.forEach((e, index) => {\n                // const type = this.getType(node);\n                // const parsedType = this.getTypeFromRawType(type);\n                const leftElement = arrayBindingPatternElements[index];\n                const leftType = global.checker.getTypeAtLocation(leftElement);\n                const parsedType = this.getTypeFromRawType(leftType);\n\n                const castExp = parsedType ? `(${parsedType})` : \"\";\n\n                // const statement = this.getIden(identation) + `${e} = (${castExp}((List<object>)${syntheticName}))[${index}]`;\n                const statement = this.getIden(identation) + `${e} = GetValue(${syntheticName}),${index})`;\n                if (index < parsedArrayBindingElements.length - 1) {\n                    arrayBindingStatement += statement + \";\\n\";\n                } else {\n                    // printStatement adds the last ;\n                    arrayBindingStatement += statement;\n                }\n            });\n\n            return arrayBindingStatement;\n        }\n\n        let operator = this.SupportedKindNames[operatorToken.kind];\n\n\n        let leftVar = undefined;\n        let rightVar = undefined;\n\n        // c# wrapper\n        if (operatorToken.kind === ts.SyntaxKind.EqualsEqualsToken || operatorToken.kind === ts.SyntaxKind.EqualsEqualsEqualsToken) {\n            if (this.COMPARISON_WRAPPER_OPEN) {\n                leftVar = this.printNode(left, 0);\n                rightVar = this.printNode(right, identation);\n                return `${this.COMPARISON_WRAPPER_OPEN}${leftVar}, ${rightVar}${this.COMPARISON_WRAPPER_CLOSE}`;\n            }\n        }\n\n        // check if boolean operators || and && because of the falsy values\n        if (operatorToken.kind === ts.SyntaxKind.BarBarToken || operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken) {\n            leftVar = this.printCondition(left, 0);\n            rightVar = this.printCondition(right, identation);\n        }  else {\n            leftVar = this.printNode(left, 0);\n            rightVar = this.printNode(right, identation);\n        }\n\n        const customOperator = this.getCustomOperatorIfAny(left, right, operatorToken);\n\n        operator = customOperator ? customOperator : operator;\n\n        return leftVar +\" \"+ operator + \" \" + rightVar.trim();\n    }\n\n    printTryStatement(node, identation: number) {\n        // const tryBody = this.printNode(node.tryBlock, 0);\n\n        let tryBody = node.tryBlock.statements.map((s) => {\n            return this.printNode(s, identation + 1);\n        }).join(\"\\n\");\n        tryBody = tryBody.replaceAll(/(\\s*)break\\s*$/gm, \"$1panic(\\\"break\\\")\"); // to do do thing regex-based\n\n        // const catchBody = this.printNode(node.catchClause.block, 0);\n        const catchBody = node.catchClause.block.statements.map((s) => this.printNode(s, identation + 1)).join(\"\\n\");\n\n        const catchLines = catchBody.split(\"\\n\").map(l => l.trim()).filter(Boolean);\n        const catchLastLine = catchLines.length ? catchLines[catchLines.length - 1] : \"\";\n        const catchBodyEndsWithReturn = catchLastLine.startsWith(\"return\")\n            || catchLastLine.startsWith(\"panic\")\n            || catchLastLine.startsWith(\"throw new\")\n            || this.blockEndsWithConditionalReturn(node.catchClause.block.statements);\n\n        const tryLines = tryBody.split(\"\\n\").map(l => l.trim()).filter(Boolean);\n        const tryLastLine = tryLines.length ? tryLines[tryLines.length - 1] : \"\";\n        const tryBodyEndsWithReturn = tryLastLine.startsWith(\"return\")\n            || tryLastLine.startsWith(\"panic\")\n            || tryLastLine.startsWith(\"throw new\")\n            || this.blockEndsWithConditionalReturn(node.tryBlock.statements);\n\n        const returNil = \"return nil\";\n        const isVoid   = this.isInsideVoidFunction(node);\n\n        const nodeEndsWithReturn = tryBodyEndsWithReturn && catchBodyEndsWithReturn && !isVoid;\n        const errorName = node.catchClause.variableDeclaration.name.escapedText;\n        const catchBlock =`\n    {\t\t\n        ${nodeEndsWithReturn ? 'ret__ :=' : ''} func(this *${this.className}) (ret_ interface{}) {\n\t\t    defer func() {\n                if ${errorName} := recover(); ${errorName} != nil {\n                    if ${errorName} == \"break\" {\n                        return\n                    }\n                    ret_ = func(this *${this.className}) interface{} {\n                        // catch block:\n                        ${catchBody}\n                        ${catchBodyEndsWithReturn ? \"\" : returNil}\n                    }(this)\n                }\n            }()\n\t\t    // try block:\n            ${tryBody}\n\t\t    ${tryBodyEndsWithReturn ? \"\" : returNil}\n\t    }(this)\n    ${nodeEndsWithReturn\n        ? `\n            if ret__ != nil {\n                return ret__\n            }\n            return nil`\n        : ''}\n        }`;\n        // add identation\n        const indentedBlock = catchBlock.split(\"\\n\").map((line) => this.getIden(identation) + line).join(\"\\n\");\n        // const catchCondOpen = this.CONDITION_OPENING ? this.CONDITION_OPENING : \" \";\n\n        return indentedBlock;\n    }\n\n    printPrefixUnaryExpression(node, identation) {\n        const {operand, operator} = node;\n        if (operator === ts.SyntaxKind.ExclamationToken) {\n            // not branch check falsy/turthy values if needed;\n            return this.getIden(identation) + this.PrefixFixOperators[operator] + this.printCondition(node.operand, 0);\n        }\n        if (operator === ts.SyntaxKind.MinusToken) {\n            return this.getIden(identation) + `OpNeg(${this.printNode(node.operand, 0)})`;\n        }\n        return this.getIden(identation) + this.PrefixFixOperators[operator] + this.printNode(operand, 0);\n    }\n\n    printNewExpression(node, identation) {\n        let expression = node.expression?.escapedText;\n        expression = expression ? expression : this.printNode(node.expression); // new Exception or new exact[string] check this out\n        if (node.arguments.length === 0) {\n            return `New${this.capitalize(expression)}()`;\n        }\n        const args = node.arguments.map(n => this.printNode(n, identation)).join(\", \");\n        if (expression.endsWith('Error')) {\n            return expression + this.LEFT_PARENTHESIS + args + this.RIGHT_PARENTHESIS;\n        }\n        return 'New' + this.capitalize(expression) + this.LEFT_PARENTHESIS + args + this.RIGHT_PARENTHESIS;\n    }\n\n    /**\n     * Override the default element-access printer with a version that walks the\n     * entire `x[y][z]` chain and builds a properly nested sequence of helper\n     * calls.  This removes the root cause of the unbalanced-parenthesis bug\n     * without any post-processing or regex hacks.\n     */\n    printElementAccessExpression(node, identation) {\n        // Maintain original special-case handling first.\n        const special = this.printElementAccessExpressionExceptionIfAny(node);\n        if (special) {\n            return special;\n        }\n\n        // Always process element access expressions the same way\n        // The binary expression handler will override this for assignments\n\n        // For right-side access, build the full nested chain\n        const keys: any[] = [];\n        let baseExpr = null;\n        let current = node as any;\n        // Walk down while the *expression* is another ElementAccessExpression.\n        while (ts.isElementAccessExpression(current)) {\n            keys.unshift(current.argumentExpression); // prepend\n            const expr = current.expression;\n            if (!ts.isElementAccessExpression(expr)) {\n                // Reached the base container.\n                baseExpr = expr;\n                break;\n            }\n            current = expr;\n        }\n\n        const containerStr = this.printNode(baseExpr, 0);\n        const keyStrs = keys.map(k => this.printNode(k, 0));\n\n        // Now build nested helpers.\n        let acc = containerStr;\n        keyStrs.forEach(k => {\n            acc = `${this.ELEMENT_ACCESS_WRAPPER_OPEN}${acc}, ${k}${this.ELEMENT_ACCESS_WRAPPER_CLOSE}`;\n        });\n\n        return acc;\n    }\n\n    isInsideVoidFunction(node: ts.Node): boolean {\n        for (let cur = node.parent; cur; cur = cur.parent) {\n            if (ts.isFunctionLike(cur)) {\n                return cur.type === undefined || cur.type.kind === ts.SyntaxKind.VoidKeyword;\n            }\n        }\n        return true;          // default-to-void if uncertain\n    }\n\n    /**\n     * Check if a block or statement contains a return statement or throws an error\n     */\n    hasReturnInBlock(statement: ts.Statement): boolean {\n        if (ts.isBlock(statement)) {\n            // A sequence of statements returns on all control paths if the last statement returns on all control paths\n            if (statement.statements.length === 0) {\n                return false;\n            }\n            return this.hasReturnInBlock(statement.statements[statement.statements.length - 1]);\n        } else if (ts.isReturnStatement(statement)) {\n            return true;\n        } else if (ts.isThrowStatement(statement)) {\n            return true;\n        } else if (ts.isIfStatement(statement)) {\n            // An if statement returns on all control paths if both the \"if\" and \"else\" branches return on all control paths\n            const ifHasReturn = this.hasReturnInBlock(statement.thenStatement);\n            if (statement.elseStatement) {\n                const elseHasReturn = this.hasReturnInBlock(statement.elseStatement);\n                return ifHasReturn && elseHasReturn;\n            }\n            return false; // No else statement, so execution can continue\n        } else if (ts.isTryStatement(statement)) {\n            // A try statement returns on all control paths if both try and catch blocks return on all control paths\n            const tryHasReturn = this.hasReturnInBlock(statement.tryBlock);\n            const catchHasReturn = this.hasReturnInBlock(statement.catchClause.block);\n            return tryHasReturn && catchHasReturn;\n        }\n        return false;\n    }\n\n    /**\n     * Check if the last statement in a block is a conditional with returns in all branches\n     */\n    blockEndsWithConditionalReturn(statements: ts.NodeArray<ts.Statement>): boolean {\n        if (statements.length === 0) {\n            return false;\n        }\n\n        const lastStatement = statements[statements.length - 1];\n        if (ts.isIfStatement(lastStatement)) {\n            // Check if this if statement has returns in all branches (only if it has an else)\n            const ifHasReturn = this.hasReturnInBlock(lastStatement.thenStatement);\n            if (lastStatement.elseStatement) {\n                const elseHasReturn = this.hasReturnInBlock(lastStatement.elseStatement);\n                return ifHasReturn && elseHasReturn;\n            }\n        }\n        if (ts.isTryStatement(lastStatement)) {\n            // Check if this try statement has returns in both try and catch blocks\n            const tryHasReturn = this.hasReturnInBlock(lastStatement.tryBlock);\n            const catchHasReturn = this.hasReturnInBlock(lastStatement.catchClause.block);\n            return tryHasReturn && catchHasReturn;\n        }\n        return false;\n    }\n\n\n}\n\n\n// get class decl node\n// Use the ts.getAllSuperTypeNodes function to get the base classes for the MyClass\n// const baseClasses = ts.getAllSuperTypeNodes(classDeclaration);\n\n// // Create a type checker\n// const typeChecker = ts.createTypeChecker(sourceFile.context.program, sourceFile.context.checker);\n\n// // Get the type of the base class\n// const baseClassType = typeChecker.getTypeAtLocation(baseClasses[0]);\n\n// // Get the class declaration for the base class\n// const baseClassDeclaration = baseClassType.symbol.valueDeclaration;\n\n// console.log(baseClassDeclaration);\n\n"],"mappings":"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","names":["ts","defaultValue","type","node","namedExports","ts","ts","SyntaxKind","ts","parserConfig","ts","parserConfig","symbol","defaultValue","path","ts","SyntaxKind","parserConfig","currentPath","ts","path"]}